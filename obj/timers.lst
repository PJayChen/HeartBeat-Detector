   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"timers.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xActiveTimerList1,"aw",%nobits
  20              		.align	2
  23              	xActiveTimerList1:
  24 0000 00000000 		.space	20
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              		.section	.bss.xActiveTimerList2,"aw",%nobits
  26              		.align	2
  29              	xActiveTimerList2:
  30 0000 00000000 		.space	20
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.pxCurrentTimerList,"aw",%nobits
  32              		.align	2
  35              	pxCurrentTimerList:
  36 0000 00000000 		.space	4
  37              		.section	.bss.pxOverflowTimerList,"aw",%nobits
  38              		.align	2
  41              	pxOverflowTimerList:
  42 0000 00000000 		.space	4
  43              		.section	.bss.xTimerQueue,"aw",%nobits
  44              		.align	2
  47              	xTimerQueue:
  48 0000 00000000 		.space	4
  49              		.section	.rodata
  50              		.align	2
  51              	.LC0:
  52 0000 546D7220 		.ascii	"Tmr Svc\000"
  52      53766300 
  53              		.section	.text.xTimerCreateTimerTask,"ax",%progbits
  54              		.align	2
  55              		.global	xTimerCreateTimerTask
  56              		.thumb
  57              		.thumb_func
  59              	xTimerCreateTimerTask:
  60              	.LFB110:
  61              		.file 1 "FreeRTOS/Source/timers.c"
   1:FreeRTOS/Source/timers.c **** /*
   2:FreeRTOS/Source/timers.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/timers.c **** 
   4:FreeRTOS/Source/timers.c **** 
   5:FreeRTOS/Source/timers.c ****     ***************************************************************************
   6:FreeRTOS/Source/timers.c ****      *                                                                       *
   7:FreeRTOS/Source/timers.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/timers.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/timers.c ****      *    available.                                                         *
  10:FreeRTOS/Source/timers.c ****      *                                                                       *
  11:FreeRTOS/Source/timers.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/timers.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/timers.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/timers.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/timers.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/timers.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/timers.c ****      *                                                                       *
  18:FreeRTOS/Source/timers.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/timers.c ****      *                                                                       *
  20:FreeRTOS/Source/timers.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/timers.c ****      *                                                                       *
  22:FreeRTOS/Source/timers.c ****     ***************************************************************************
  23:FreeRTOS/Source/timers.c **** 
  24:FreeRTOS/Source/timers.c **** 
  25:FreeRTOS/Source/timers.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/timers.c **** 
  27:FreeRTOS/Source/timers.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/timers.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/timers.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/timers.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/timers.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/timers.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/timers.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/timers.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/timers.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/timers.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/timers.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/timers.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/timers.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/timers.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/timers.c **** 
  42:FreeRTOS/Source/timers.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/timers.c **** 
  44:FreeRTOS/Source/timers.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/timers.c ****     contact details.
  46:FreeRTOS/Source/timers.c **** 
  47:FreeRTOS/Source/timers.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/timers.c ****     critical systems.
  49:FreeRTOS/Source/timers.c **** 
  50:FreeRTOS/Source/timers.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/timers.c ****     licensing and training services.
  52:FreeRTOS/Source/timers.c **** */
  53:FreeRTOS/Source/timers.c **** 
  54:FreeRTOS/Source/timers.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  55:FreeRTOS/Source/timers.c **** all the API functions to use the MPU wrappers.  That should only be done when
  56:FreeRTOS/Source/timers.c **** task.h is included from an application file. */
  57:FreeRTOS/Source/timers.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  58:FreeRTOS/Source/timers.c **** 
  59:FreeRTOS/Source/timers.c **** #include "FreeRTOS.h"
  60:FreeRTOS/Source/timers.c **** #include "task.h"
  61:FreeRTOS/Source/timers.c **** #include "queue.h"
  62:FreeRTOS/Source/timers.c **** #include "timers.h"
  63:FreeRTOS/Source/timers.c **** 
  64:FreeRTOS/Source/timers.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  65:FreeRTOS/Source/timers.c **** 
  66:FreeRTOS/Source/timers.c **** /* This entire source file will be skipped if the application is not configured
  67:FreeRTOS/Source/timers.c **** to include software timer functionality.  This #if is closed at the very bottom
  68:FreeRTOS/Source/timers.c **** of this file.  If you want to include software timer functionality then ensure
  69:FreeRTOS/Source/timers.c **** configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
  70:FreeRTOS/Source/timers.c **** #if ( configUSE_TIMERS == 1 )
  71:FreeRTOS/Source/timers.c **** 
  72:FreeRTOS/Source/timers.c **** /* Misc definitions. */
  73:FreeRTOS/Source/timers.c **** #define tmrNO_DELAY		( portTickType ) 0U
  74:FreeRTOS/Source/timers.c **** 
  75:FreeRTOS/Source/timers.c **** /* The definition of the timers themselves. */
  76:FreeRTOS/Source/timers.c **** typedef struct tmrTimerControl
  77:FreeRTOS/Source/timers.c **** {
  78:FreeRTOS/Source/timers.c **** 	const signed char		*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included 
  79:FreeRTOS/Source/timers.c **** 	xListItem				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for ev
  80:FreeRTOS/Source/timers.c **** 	portTickType			xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
  81:FreeRTOS/Source/timers.c **** 	unsigned portBASE_TYPE	uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically rest
  82:FreeRTOS/Source/timers.c **** 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified 
  83:FreeRTOS/Source/timers.c **** 	tmrTIMER_CALLBACK		pxCallbackFunction;	/*<< The function that will be called when the timer expire
  84:FreeRTOS/Source/timers.c **** } xTIMER;
  85:FreeRTOS/Source/timers.c **** 
  86:FreeRTOS/Source/timers.c **** /* The definition of messages that can be sent and received on the timer
  87:FreeRTOS/Source/timers.c **** queue. */
  88:FreeRTOS/Source/timers.c **** typedef struct tmrTimerQueueMessage
  89:FreeRTOS/Source/timers.c **** {
  90:FreeRTOS/Source/timers.c **** 	portBASE_TYPE			xMessageID;			/*<< The command being sent to the timer service task. */
  91:FreeRTOS/Source/timers.c **** 	portTickType			xMessageValue;		/*<< An optional value used by a subset of commands, for example, w
  92:FreeRTOS/Source/timers.c **** 	xTIMER *				pxTimer;			/*<< The timer to which the command will be applied. */
  93:FreeRTOS/Source/timers.c **** } xTIMER_MESSAGE;
  94:FreeRTOS/Source/timers.c **** 
  95:FreeRTOS/Source/timers.c **** 
  96:FreeRTOS/Source/timers.c **** /* The list in which active timers are stored.  Timers are referenced in expire
  97:FreeRTOS/Source/timers.c **** time order, with the nearest expiry time at the front of the list.  Only the
  98:FreeRTOS/Source/timers.c **** timer service task is allowed to access xActiveTimerList. */
  99:FreeRTOS/Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList1;
 100:FreeRTOS/Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList2;
 101:FreeRTOS/Source/timers.c **** PRIVILEGED_DATA static xList *pxCurrentTimerList;
 102:FreeRTOS/Source/timers.c **** PRIVILEGED_DATA static xList *pxOverflowTimerList;
 103:FreeRTOS/Source/timers.c **** 
 104:FreeRTOS/Source/timers.c **** /* A queue that is used to send commands to the timer service task. */
 105:FreeRTOS/Source/timers.c **** PRIVILEGED_DATA static xQueueHandle xTimerQueue = NULL;
 106:FreeRTOS/Source/timers.c **** 
 107:FreeRTOS/Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 108:FreeRTOS/Source/timers.c **** 	
 109:FreeRTOS/Source/timers.c **** 	PRIVILEGED_DATA static xTaskHandle xTimerTaskHandle = NULL;
 110:FreeRTOS/Source/timers.c **** 	
 111:FreeRTOS/Source/timers.c **** #endif
 112:FreeRTOS/Source/timers.c **** 
 113:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 114:FreeRTOS/Source/timers.c **** 
 115:FreeRTOS/Source/timers.c **** /*
 116:FreeRTOS/Source/timers.c ****  * Initialise the infrastructure used by the timer service task if it has not
 117:FreeRTOS/Source/timers.c ****  * been initialised already.
 118:FreeRTOS/Source/timers.c ****  */
 119:FreeRTOS/Source/timers.c **** static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
 120:FreeRTOS/Source/timers.c **** 
 121:FreeRTOS/Source/timers.c **** /*
 122:FreeRTOS/Source/timers.c ****  * The timer service task (daemon).  Timer functionality is controlled by this
 123:FreeRTOS/Source/timers.c ****  * task.  Other tasks communicate with the timer service task using the
 124:FreeRTOS/Source/timers.c ****  * xTimerQueue queue.
 125:FreeRTOS/Source/timers.c ****  */
 126:FreeRTOS/Source/timers.c **** static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
 127:FreeRTOS/Source/timers.c **** 
 128:FreeRTOS/Source/timers.c **** /*
 129:FreeRTOS/Source/timers.c ****  * Called by the timer service task to interpret and process a command it
 130:FreeRTOS/Source/timers.c ****  * received on the timer queue.
 131:FreeRTOS/Source/timers.c ****  */
 132:FreeRTOS/Source/timers.c **** static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
 133:FreeRTOS/Source/timers.c **** 
 134:FreeRTOS/Source/timers.c **** /*
 135:FreeRTOS/Source/timers.c ****  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 136:FreeRTOS/Source/timers.c ****  * depending on if the expire time causes a timer counter overflow.
 137:FreeRTOS/Source/timers.c ****  */
 138:FreeRTOS/Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 139:FreeRTOS/Source/timers.c **** 
 140:FreeRTOS/Source/timers.c **** /*
 141:FreeRTOS/Source/timers.c ****  * An active timer has reached its expire time.  Reload the timer if it is an
 142:FreeRTOS/Source/timers.c ****  * auto reload timer, then call its callback.
 143:FreeRTOS/Source/timers.c ****  */
 144:FreeRTOS/Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow ) PRIVILEGE
 145:FreeRTOS/Source/timers.c **** 
 146:FreeRTOS/Source/timers.c **** /*
 147:FreeRTOS/Source/timers.c ****  * The tick count has overflowed.  Switch the timer lists after ensuring the
 148:FreeRTOS/Source/timers.c ****  * current timer list does not still reference some timers.
 149:FreeRTOS/Source/timers.c ****  */
 150:FreeRTOS/Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime ) PRIVILEGED_FUNCTION;
 151:FreeRTOS/Source/timers.c **** 
 152:FreeRTOS/Source/timers.c **** /*
 153:FreeRTOS/Source/timers.c ****  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 154:FreeRTOS/Source/timers.c ****  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 155:FreeRTOS/Source/timers.c ****  */
 156:FreeRTOS/Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION
 157:FreeRTOS/Source/timers.c **** 
 158:FreeRTOS/Source/timers.c **** /*
 159:FreeRTOS/Source/timers.c ****  * If the timer list contains any active timers then return the expire time of
 160:FreeRTOS/Source/timers.c ****  * the timer that will expire first and set *pxListWasEmpty to false.  If the
 161:FreeRTOS/Source/timers.c ****  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 162:FreeRTOS/Source/timers.c ****  * to pdTRUE.
 163:FreeRTOS/Source/timers.c ****  */
 164:FreeRTOS/Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty ) PRIVILEGED_FUNCTION;
 165:FreeRTOS/Source/timers.c **** 
 166:FreeRTOS/Source/timers.c **** /*
 167:FreeRTOS/Source/timers.c ****  * If a timer has expired, process it.  Otherwise, block the timer service task
 168:FreeRTOS/Source/timers.c ****  * until either a timer does expire or a command is received.
 169:FreeRTOS/Source/timers.c ****  */
 170:FreeRTOS/Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 171:FreeRTOS/Source/timers.c **** 
 172:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 173:FreeRTOS/Source/timers.c **** 
 174:FreeRTOS/Source/timers.c **** portBASE_TYPE xTimerCreateTimerTask( void )
 175:FreeRTOS/Source/timers.c **** {
  62              		.loc 1 175 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 1, uses_anonymous_args = 0
  66 0000 80B5     		push	{r7, lr}
  67              	.LCFI0:
  68              		.cfi_def_cfa_offset 8
  69              		.cfi_offset 14, -4
  70              		.cfi_offset 7, -8
  71 0002 86B0     		sub	sp, sp, #24
  72              	.LCFI1:
  73              		.cfi_def_cfa_offset 32
  74 0004 04AF     		add	r7, sp, #16
  75              	.LCFI2:
  76              		.cfi_def_cfa 7, 16
 176:FreeRTOS/Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
  77              		.loc 1 176 0
  78 0006 4FF00003 		mov	r3, #0
  79 000a 7B60     		str	r3, [r7, #4]
 177:FreeRTOS/Source/timers.c **** 
 178:FreeRTOS/Source/timers.c **** 	/* This function is called when the scheduler is started if
 179:FreeRTOS/Source/timers.c **** 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
 180:FreeRTOS/Source/timers.c **** 	timer service task has been created/initialised.  If timers have already
 181:FreeRTOS/Source/timers.c **** 	been created then the initialisation will already have been performed. */
 182:FreeRTOS/Source/timers.c **** 	prvCheckForValidListAndQueue();
  80              		.loc 1 182 0
  81 000c FFF7FEFF 		bl	prvCheckForValidListAndQueue
 183:FreeRTOS/Source/timers.c **** 
 184:FreeRTOS/Source/timers.c **** 	if( xTimerQueue != NULL )
  82              		.loc 1 184 0
  83 0010 40F20003 		movw	r3, #:lower16:xTimerQueue
  84 0014 C0F20003 		movt	r3, #:upper16:xTimerQueue
  85 0018 1B68     		ldr	r3, [r3, #0]
  86 001a 002B     		cmp	r3, #0
  87 001c 1AD0     		beq	.L2
 185:FreeRTOS/Source/timers.c **** 	{
 186:FreeRTOS/Source/timers.c **** 		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 187:FreeRTOS/Source/timers.c **** 		{
 188:FreeRTOS/Source/timers.c **** 			/* Create the timer task, storing its handle in xTimerTaskHandle so
 189:FreeRTOS/Source/timers.c **** 			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
 190:FreeRTOS/Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
 191:FreeRTOS/Source/timers.c **** 		}
 192:FreeRTOS/Source/timers.c **** 		#else
 193:FreeRTOS/Source/timers.c **** 		{
 194:FreeRTOS/Source/timers.c **** 			/* Create the timer task without storing its handle. */
 195:FreeRTOS/Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
  88              		.loc 1 195 0
  89 001e 4FF00103 		mov	r3, #1
  90 0022 0093     		str	r3, [sp, #0]
  91 0024 4FF00003 		mov	r3, #0
  92 0028 0193     		str	r3, [sp, #4]
  93 002a 4FF00003 		mov	r3, #0
  94 002e 0293     		str	r3, [sp, #8]
  95 0030 4FF00003 		mov	r3, #0
  96 0034 0393     		str	r3, [sp, #12]
  97 0036 40F20000 		movw	r0, #:lower16:prvTimerTask
  98 003a C0F20000 		movt	r0, #:upper16:prvTimerTask
  99 003e 40F20001 		movw	r1, #:lower16:.LC0
 100 0042 C0F20001 		movt	r1, #:upper16:.LC0
 101 0046 4FF48072 		mov	r2, #256
 102 004a 4FF00003 		mov	r3, #0
 103 004e FFF7FEFF 		bl	xTaskGenericCreate
 104 0052 7860     		str	r0, [r7, #4]
 105              	.L2:
 196:FreeRTOS/Source/timers.c **** 		}
 197:FreeRTOS/Source/timers.c **** 		#endif
 198:FreeRTOS/Source/timers.c **** 	}
 199:FreeRTOS/Source/timers.c **** 
 200:FreeRTOS/Source/timers.c **** 	configASSERT( xReturn );
 201:FreeRTOS/Source/timers.c **** 	return xReturn;
 106              		.loc 1 201 0
 107 0054 7B68     		ldr	r3, [r7, #4]
 202:FreeRTOS/Source/timers.c **** }
 108              		.loc 1 202 0
 109 0056 1846     		mov	r0, r3
 110 0058 07F10807 		add	r7, r7, #8
 111 005c BD46     		mov	sp, r7
 112 005e 80BD     		pop	{r7, pc}
 113              		.cfi_endproc
 114              	.LFE110:
 116              		.section	.text.xTimerCreate,"ax",%progbits
 117              		.align	2
 118              		.global	xTimerCreate
 119              		.thumb
 120              		.thumb_func
 122              	xTimerCreate:
 123              	.LFB111:
 203:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 204:FreeRTOS/Source/timers.c **** 
 205:FreeRTOS/Source/timers.c **** xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsign
 206:FreeRTOS/Source/timers.c **** {
 124              		.loc 1 206 0
 125              		.cfi_startproc
 126              		@ args = 4, pretend = 0, frame = 24
 127              		@ frame_needed = 1, uses_anonymous_args = 0
 128 0000 80B5     		push	{r7, lr}
 129              	.LCFI3:
 130              		.cfi_def_cfa_offset 8
 131              		.cfi_offset 14, -4
 132              		.cfi_offset 7, -8
 133 0002 86B0     		sub	sp, sp, #24
 134              	.LCFI4:
 135              		.cfi_def_cfa_offset 32
 136 0004 00AF     		add	r7, sp, #0
 137              	.LCFI5:
 138              		.cfi_def_cfa_register 7
 139 0006 F860     		str	r0, [r7, #12]
 140 0008 B960     		str	r1, [r7, #8]
 141 000a 7A60     		str	r2, [r7, #4]
 142 000c 3B60     		str	r3, [r7, #0]
 207:FreeRTOS/Source/timers.c **** xTIMER *pxNewTimer;
 208:FreeRTOS/Source/timers.c **** 
 209:FreeRTOS/Source/timers.c **** 	/* Allocate the timer structure. */
 210:FreeRTOS/Source/timers.c **** 	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 143              		.loc 1 210 0
 144 000e BB68     		ldr	r3, [r7, #8]
 145 0010 002B     		cmp	r3, #0
 146 0012 03D1     		bne	.L4
 211:FreeRTOS/Source/timers.c **** 	{
 212:FreeRTOS/Source/timers.c **** 		pxNewTimer = NULL;
 147              		.loc 1 212 0
 148 0014 4FF00003 		mov	r3, #0
 149 0018 7B61     		str	r3, [r7, #20]
 150 001a 1FE0     		b	.L5
 151              	.L4:
 213:FreeRTOS/Source/timers.c **** 		configASSERT( ( xTimerPeriodInTicks > 0 ) );
 214:FreeRTOS/Source/timers.c **** 	}
 215:FreeRTOS/Source/timers.c **** 	else
 216:FreeRTOS/Source/timers.c **** 	{
 217:FreeRTOS/Source/timers.c **** 		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 152              		.loc 1 217 0
 153 001c 4FF02800 		mov	r0, #40
 154 0020 FFF7FEFF 		bl	malloc
 155 0024 0346     		mov	r3, r0
 156 0026 7B61     		str	r3, [r7, #20]
 218:FreeRTOS/Source/timers.c **** 		if( pxNewTimer != NULL )
 157              		.loc 1 218 0
 158 0028 7B69     		ldr	r3, [r7, #20]
 159 002a 002B     		cmp	r3, #0
 160 002c 16D0     		beq	.L5
 219:FreeRTOS/Source/timers.c **** 		{
 220:FreeRTOS/Source/timers.c **** 			/* Ensure the infrastructure used by the timer service task has been
 221:FreeRTOS/Source/timers.c **** 			created/initialised. */
 222:FreeRTOS/Source/timers.c **** 			prvCheckForValidListAndQueue();
 161              		.loc 1 222 0
 162 002e FFF7FEFF 		bl	prvCheckForValidListAndQueue
 223:FreeRTOS/Source/timers.c **** 	
 224:FreeRTOS/Source/timers.c **** 			/* Initialise the timer structure members using the function parameters. */
 225:FreeRTOS/Source/timers.c **** 			pxNewTimer->pcTimerName = pcTimerName;
 163              		.loc 1 225 0
 164 0032 7B69     		ldr	r3, [r7, #20]
 165 0034 FA68     		ldr	r2, [r7, #12]
 166 0036 1A60     		str	r2, [r3, #0]
 226:FreeRTOS/Source/timers.c **** 			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 167              		.loc 1 226 0
 168 0038 7B69     		ldr	r3, [r7, #20]
 169 003a BA68     		ldr	r2, [r7, #8]
 170 003c 9A61     		str	r2, [r3, #24]
 227:FreeRTOS/Source/timers.c **** 			pxNewTimer->uxAutoReload = uxAutoReload;
 171              		.loc 1 227 0
 172 003e 7B69     		ldr	r3, [r7, #20]
 173 0040 7A68     		ldr	r2, [r7, #4]
 174 0042 DA61     		str	r2, [r3, #28]
 228:FreeRTOS/Source/timers.c **** 			pxNewTimer->pvTimerID = pvTimerID;
 175              		.loc 1 228 0
 176 0044 7B69     		ldr	r3, [r7, #20]
 177 0046 3A68     		ldr	r2, [r7, #0]
 178 0048 1A62     		str	r2, [r3, #32]
 229:FreeRTOS/Source/timers.c **** 			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 179              		.loc 1 229 0
 180 004a 7B69     		ldr	r3, [r7, #20]
 181 004c 3A6A     		ldr	r2, [r7, #32]
 182 004e 5A62     		str	r2, [r3, #36]
 230:FreeRTOS/Source/timers.c **** 			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 183              		.loc 1 230 0
 184 0050 7B69     		ldr	r3, [r7, #20]
 185 0052 03F10403 		add	r3, r3, #4
 186 0056 1846     		mov	r0, r3
 187 0058 FFF7FEFF 		bl	vListInitialiseItem
 188              	.L5:
 231:FreeRTOS/Source/timers.c **** 			
 232:FreeRTOS/Source/timers.c **** 			traceTIMER_CREATE( pxNewTimer );
 233:FreeRTOS/Source/timers.c **** 		}
 234:FreeRTOS/Source/timers.c **** 		else
 235:FreeRTOS/Source/timers.c **** 		{
 236:FreeRTOS/Source/timers.c **** 			traceTIMER_CREATE_FAILED();
 237:FreeRTOS/Source/timers.c **** 		}
 238:FreeRTOS/Source/timers.c **** 	}
 239:FreeRTOS/Source/timers.c **** 	
 240:FreeRTOS/Source/timers.c **** 	return ( xTimerHandle ) pxNewTimer;
 189              		.loc 1 240 0
 190 005c 7B69     		ldr	r3, [r7, #20]
 241:FreeRTOS/Source/timers.c **** }
 191              		.loc 1 241 0
 192 005e 1846     		mov	r0, r3
 193 0060 07F11807 		add	r7, r7, #24
 194 0064 BD46     		mov	sp, r7
 195 0066 80BD     		pop	{r7, pc}
 196              		.cfi_endproc
 197              	.LFE111:
 199              		.section	.text.xTimerGenericCommand,"ax",%progbits
 200              		.align	2
 201              		.global	xTimerGenericCommand
 202              		.thumb
 203              		.thumb_func
 205              	xTimerGenericCommand:
 206              	.LFB112:
 242:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 243:FreeRTOS/Source/timers.c **** 
 244:FreeRTOS/Source/timers.c **** portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOp
 245:FreeRTOS/Source/timers.c **** {
 207              		.loc 1 245 0
 208              		.cfi_startproc
 209              		@ args = 4, pretend = 0, frame = 32
 210              		@ frame_needed = 1, uses_anonymous_args = 0
 211 0000 80B5     		push	{r7, lr}
 212              	.LCFI6:
 213              		.cfi_def_cfa_offset 8
 214              		.cfi_offset 14, -4
 215              		.cfi_offset 7, -8
 216 0002 88B0     		sub	sp, sp, #32
 217              	.LCFI7:
 218              		.cfi_def_cfa_offset 40
 219 0004 00AF     		add	r7, sp, #0
 220              	.LCFI8:
 221              		.cfi_def_cfa_register 7
 222 0006 F860     		str	r0, [r7, #12]
 223 0008 B960     		str	r1, [r7, #8]
 224 000a 7A60     		str	r2, [r7, #4]
 225 000c 3B60     		str	r3, [r7, #0]
 246:FreeRTOS/Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
 226              		.loc 1 246 0
 227 000e 4FF00003 		mov	r3, #0
 228 0012 FB61     		str	r3, [r7, #28]
 247:FreeRTOS/Source/timers.c **** xTIMER_MESSAGE xMessage;
 248:FreeRTOS/Source/timers.c **** 
 249:FreeRTOS/Source/timers.c **** 	/* Send a message to the timer service task to perform a particular action
 250:FreeRTOS/Source/timers.c **** 	on a particular timer definition. */
 251:FreeRTOS/Source/timers.c **** 	if( xTimerQueue != NULL )
 229              		.loc 1 251 0
 230 0014 40F20003 		movw	r3, #:lower16:xTimerQueue
 231 0018 C0F20003 		movt	r3, #:upper16:xTimerQueue
 232 001c 1B68     		ldr	r3, [r3, #0]
 233 001e 002B     		cmp	r3, #0
 234 0020 3DD0     		beq	.L7
 252:FreeRTOS/Source/timers.c **** 	{
 253:FreeRTOS/Source/timers.c **** 		/* Send a command to the timer service task to start the xTimer timer. */
 254:FreeRTOS/Source/timers.c **** 		xMessage.xMessageID = xCommandID;
 235              		.loc 1 254 0
 236 0022 BB68     		ldr	r3, [r7, #8]
 237 0024 3B61     		str	r3, [r7, #16]
 255:FreeRTOS/Source/timers.c **** 		xMessage.xMessageValue = xOptionalValue;
 238              		.loc 1 255 0
 239 0026 7B68     		ldr	r3, [r7, #4]
 240 0028 7B61     		str	r3, [r7, #20]
 256:FreeRTOS/Source/timers.c **** 		xMessage.pxTimer = ( xTIMER * ) xTimer;
 241              		.loc 1 256 0
 242 002a FB68     		ldr	r3, [r7, #12]
 243 002c BB61     		str	r3, [r7, #24]
 257:FreeRTOS/Source/timers.c **** 
 258:FreeRTOS/Source/timers.c **** 		if( pxHigherPriorityTaskWoken == NULL )
 244              		.loc 1 258 0
 245 002e 3B68     		ldr	r3, [r7, #0]
 246 0030 002B     		cmp	r3, #0
 247 0032 25D1     		bne	.L8
 259:FreeRTOS/Source/timers.c **** 		{
 260:FreeRTOS/Source/timers.c **** 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 248              		.loc 1 260 0
 249 0034 FFF7FEFF 		bl	xTaskGetSchedulerState
 250 0038 0346     		mov	r3, r0
 251 003a 012B     		cmp	r3, #1
 252 003c 0FD1     		bne	.L9
 261:FreeRTOS/Source/timers.c **** 			{
 262:FreeRTOS/Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 253              		.loc 1 262 0
 254 003e 40F20003 		movw	r3, #:lower16:xTimerQueue
 255 0042 C0F20003 		movt	r3, #:upper16:xTimerQueue
 256 0046 1B68     		ldr	r3, [r3, #0]
 257 0048 1846     		mov	r0, r3
 258 004a 07F11003 		add	r3, r7, #16
 259 004e 1946     		mov	r1, r3
 260 0050 BA6A     		ldr	r2, [r7, #40]
 261 0052 4FF00003 		mov	r3, #0
 262 0056 FFF7FEFF 		bl	xQueueGenericSend
 263 005a F861     		str	r0, [r7, #28]
 264 005c 1FE0     		b	.L7
 265              	.L9:
 263:FreeRTOS/Source/timers.c **** 			}
 264:FreeRTOS/Source/timers.c **** 			else
 265:FreeRTOS/Source/timers.c **** 			{
 266:FreeRTOS/Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 266              		.loc 1 266 0
 267 005e 40F20003 		movw	r3, #:lower16:xTimerQueue
 268 0062 C0F20003 		movt	r3, #:upper16:xTimerQueue
 269 0066 1B68     		ldr	r3, [r3, #0]
 270 0068 1846     		mov	r0, r3
 271 006a 07F11003 		add	r3, r7, #16
 272 006e 1946     		mov	r1, r3
 273 0070 4FF00002 		mov	r2, #0
 274 0074 4FF00003 		mov	r3, #0
 275 0078 FFF7FEFF 		bl	xQueueGenericSend
 276 007c F861     		str	r0, [r7, #28]
 277 007e 0EE0     		b	.L7
 278              	.L8:
 267:FreeRTOS/Source/timers.c **** 			}
 268:FreeRTOS/Source/timers.c **** 		}
 269:FreeRTOS/Source/timers.c **** 		else
 270:FreeRTOS/Source/timers.c **** 		{
 271:FreeRTOS/Source/timers.c **** 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 279              		.loc 1 271 0
 280 0080 40F20003 		movw	r3, #:lower16:xTimerQueue
 281 0084 C0F20003 		movt	r3, #:upper16:xTimerQueue
 282 0088 1B68     		ldr	r3, [r3, #0]
 283 008a 1846     		mov	r0, r3
 284 008c 07F11003 		add	r3, r7, #16
 285 0090 1946     		mov	r1, r3
 286 0092 3A68     		ldr	r2, [r7, #0]
 287 0094 4FF00003 		mov	r3, #0
 288 0098 FFF7FEFF 		bl	xQueueGenericSendFromISR
 289 009c F861     		str	r0, [r7, #28]
 290              	.L7:
 272:FreeRTOS/Source/timers.c **** 		}
 273:FreeRTOS/Source/timers.c **** 		
 274:FreeRTOS/Source/timers.c **** 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
 275:FreeRTOS/Source/timers.c **** 	}
 276:FreeRTOS/Source/timers.c **** 	
 277:FreeRTOS/Source/timers.c **** 	return xReturn;
 291              		.loc 1 277 0
 292 009e FB69     		ldr	r3, [r7, #28]
 278:FreeRTOS/Source/timers.c **** }
 293              		.loc 1 278 0
 294 00a0 1846     		mov	r0, r3
 295 00a2 07F12007 		add	r7, r7, #32
 296 00a6 BD46     		mov	sp, r7
 297 00a8 80BD     		pop	{r7, pc}
 298              		.cfi_endproc
 299              	.LFE112:
 301 00aa 00BF     		.section	.text.prvProcessExpiredTimer,"ax",%progbits
 302              		.align	2
 303              		.thumb
 304              		.thumb_func
 306              	prvProcessExpiredTimer:
 307              	.LFB113:
 279:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 280:FreeRTOS/Source/timers.c **** 
 281:FreeRTOS/Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 282:FreeRTOS/Source/timers.c **** 
 283:FreeRTOS/Source/timers.c **** 	xTaskHandle xTimerGetTimerDaemonTaskHandle( void )
 284:FreeRTOS/Source/timers.c **** 	{
 285:FreeRTOS/Source/timers.c **** 		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 286:FreeRTOS/Source/timers.c **** 		started, then xTimerTaskHandle will be NULL. */
 287:FreeRTOS/Source/timers.c **** 		configASSERT( ( xTimerTaskHandle != NULL ) );
 288:FreeRTOS/Source/timers.c **** 		return xTimerTaskHandle;
 289:FreeRTOS/Source/timers.c **** 	}
 290:FreeRTOS/Source/timers.c **** 	
 291:FreeRTOS/Source/timers.c **** #endif
 292:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 293:FreeRTOS/Source/timers.c **** 
 294:FreeRTOS/Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
 295:FreeRTOS/Source/timers.c **** {
 308              		.loc 1 295 0
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 16
 311              		@ frame_needed = 1, uses_anonymous_args = 0
 312 0000 80B5     		push	{r7, lr}
 313              	.LCFI9:
 314              		.cfi_def_cfa_offset 8
 315              		.cfi_offset 14, -4
 316              		.cfi_offset 7, -8
 317 0002 86B0     		sub	sp, sp, #24
 318              	.LCFI10:
 319              		.cfi_def_cfa_offset 32
 320 0004 02AF     		add	r7, sp, #8
 321              	.LCFI11:
 322              		.cfi_def_cfa 7, 24
 323 0006 7860     		str	r0, [r7, #4]
 324 0008 3960     		str	r1, [r7, #0]
 296:FreeRTOS/Source/timers.c **** xTIMER *pxTimer;
 297:FreeRTOS/Source/timers.c **** portBASE_TYPE xResult;
 298:FreeRTOS/Source/timers.c **** 
 299:FreeRTOS/Source/timers.c **** 	/* Remove the timer from the list of active timers.  A check has already
 300:FreeRTOS/Source/timers.c **** 	been performed to ensure the list is not empty. */
 301:FreeRTOS/Source/timers.c **** 	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 325              		.loc 1 301 0
 326 000a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 327 000e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 328 0012 1B68     		ldr	r3, [r3, #0]
 329 0014 DB68     		ldr	r3, [r3, #12]
 330 0016 DB68     		ldr	r3, [r3, #12]
 331 0018 FB60     		str	r3, [r7, #12]
 302:FreeRTOS/Source/timers.c **** 	vListRemove( &( pxTimer->xTimerListItem ) );
 332              		.loc 1 302 0
 333 001a FB68     		ldr	r3, [r7, #12]
 334 001c 03F10403 		add	r3, r3, #4
 335 0020 1846     		mov	r0, r3
 336 0022 FFF7FEFF 		bl	vListRemove
 303:FreeRTOS/Source/timers.c **** 	traceTIMER_EXPIRED( pxTimer );
 304:FreeRTOS/Source/timers.c **** 
 305:FreeRTOS/Source/timers.c **** 	/* If the timer is an auto reload timer then calculate the next
 306:FreeRTOS/Source/timers.c **** 	expiry time and re-insert the timer in the list of active timers. */
 307:FreeRTOS/Source/timers.c **** 	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 337              		.loc 1 307 0
 338 0026 FB68     		ldr	r3, [r7, #12]
 339 0028 DB69     		ldr	r3, [r3, #28]
 340 002a 012B     		cmp	r3, #1
 341 002c 18D1     		bne	.L11
 308:FreeRTOS/Source/timers.c **** 	{
 309:FreeRTOS/Source/timers.c **** 		/* This is the only time a timer is inserted into a list using
 310:FreeRTOS/Source/timers.c **** 		a time relative to anything other than the current time.  It
 311:FreeRTOS/Source/timers.c **** 		will therefore be inserted into the correct list relative to
 312:FreeRTOS/Source/timers.c **** 		the time this task thinks it is now, even if a command to
 313:FreeRTOS/Source/timers.c **** 		switch lists due to a tick count overflow is already waiting in
 314:FreeRTOS/Source/timers.c **** 		the timer queue. */
 315:FreeRTOS/Source/timers.c **** 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTim
 342              		.loc 1 315 0
 343 002e FB68     		ldr	r3, [r7, #12]
 344 0030 9A69     		ldr	r2, [r3, #24]
 345 0032 7B68     		ldr	r3, [r7, #4]
 346 0034 D318     		adds	r3, r2, r3
 347 0036 F868     		ldr	r0, [r7, #12]
 348 0038 1946     		mov	r1, r3
 349 003a 3A68     		ldr	r2, [r7, #0]
 350 003c 7B68     		ldr	r3, [r7, #4]
 351 003e FFF7FEFF 		bl	prvInsertTimerInActiveList
 352 0042 0346     		mov	r3, r0
 353 0044 012B     		cmp	r3, #1
 354 0046 0BD1     		bne	.L11
 316:FreeRTOS/Source/timers.c **** 		{
 317:FreeRTOS/Source/timers.c **** 			/* The timer expired before it was added to the active timer
 318:FreeRTOS/Source/timers.c **** 			list.  Reload it now.  */
 319:FreeRTOS/Source/timers.c **** 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 355              		.loc 1 319 0
 356 0048 4FF00003 		mov	r3, #0
 357 004c 0093     		str	r3, [sp, #0]
 358 004e F868     		ldr	r0, [r7, #12]
 359 0050 4FF00001 		mov	r1, #0
 360 0054 7A68     		ldr	r2, [r7, #4]
 361 0056 4FF00003 		mov	r3, #0
 362 005a FFF7FEFF 		bl	xTimerGenericCommand
 363 005e B860     		str	r0, [r7, #8]
 364              	.L11:
 320:FreeRTOS/Source/timers.c **** 			configASSERT( xResult );
 321:FreeRTOS/Source/timers.c **** 			( void ) xResult;
 322:FreeRTOS/Source/timers.c **** 		}
 323:FreeRTOS/Source/timers.c **** 	}
 324:FreeRTOS/Source/timers.c **** 
 325:FreeRTOS/Source/timers.c **** 	/* Call the timer callback. */
 326:FreeRTOS/Source/timers.c **** 	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 365              		.loc 1 326 0
 366 0060 FB68     		ldr	r3, [r7, #12]
 367 0062 5B6A     		ldr	r3, [r3, #36]
 368 0064 F868     		ldr	r0, [r7, #12]
 369 0066 9847     		blx	r3
 327:FreeRTOS/Source/timers.c **** }
 370              		.loc 1 327 0
 371 0068 07F11007 		add	r7, r7, #16
 372 006c BD46     		mov	sp, r7
 373 006e 80BD     		pop	{r7, pc}
 374              		.cfi_endproc
 375              	.LFE113:
 377              		.section	.text.prvTimerTask,"ax",%progbits
 378              		.align	2
 379              		.thumb
 380              		.thumb_func
 382              	prvTimerTask:
 383              	.LFB114:
 328:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 329:FreeRTOS/Source/timers.c **** 
 330:FreeRTOS/Source/timers.c **** static void prvTimerTask( void *pvParameters )
 331:FreeRTOS/Source/timers.c **** {
 384              		.loc 1 331 0
 385              		.cfi_startproc
 386              		@ args = 0, pretend = 0, frame = 16
 387              		@ frame_needed = 1, uses_anonymous_args = 0
 388 0000 80B5     		push	{r7, lr}
 389              	.LCFI12:
 390              		.cfi_def_cfa_offset 8
 391              		.cfi_offset 14, -4
 392              		.cfi_offset 7, -8
 393 0002 84B0     		sub	sp, sp, #16
 394              	.LCFI13:
 395              		.cfi_def_cfa_offset 24
 396 0004 00AF     		add	r7, sp, #0
 397              	.LCFI14:
 398              		.cfi_def_cfa_register 7
 399 0006 7860     		str	r0, [r7, #4]
 400              	.L13:
 332:FreeRTOS/Source/timers.c **** portTickType xNextExpireTime;
 333:FreeRTOS/Source/timers.c **** portBASE_TYPE xListWasEmpty;
 334:FreeRTOS/Source/timers.c **** 
 335:FreeRTOS/Source/timers.c **** 	/* Just to avoid compiler warnings. */
 336:FreeRTOS/Source/timers.c **** 	( void ) pvParameters;
 337:FreeRTOS/Source/timers.c **** 
 338:FreeRTOS/Source/timers.c **** 	for( ;; )
 339:FreeRTOS/Source/timers.c **** 	{
 340:FreeRTOS/Source/timers.c **** 		/* Query the timers list to see if it contains any timers, and if so,
 341:FreeRTOS/Source/timers.c **** 		obtain the time at which the next timer will expire. */
 342:FreeRTOS/Source/timers.c **** 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 401              		.loc 1 342 0 discriminator 1
 402 0008 07F10803 		add	r3, r7, #8
 403 000c 1846     		mov	r0, r3
 404 000e FFF7FEFF 		bl	prvGetNextExpireTime
 405 0012 F860     		str	r0, [r7, #12]
 343:FreeRTOS/Source/timers.c **** 
 344:FreeRTOS/Source/timers.c **** 		/* If a timer has expired, process it.  Otherwise, block this task
 345:FreeRTOS/Source/timers.c **** 		until either a timer does expire, or a command is received. */
 346:FreeRTOS/Source/timers.c **** 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 406              		.loc 1 346 0 discriminator 1
 407 0014 BB68     		ldr	r3, [r7, #8]
 408 0016 F868     		ldr	r0, [r7, #12]
 409 0018 1946     		mov	r1, r3
 410 001a FFF7FEFF 		bl	prvProcessTimerOrBlockTask
 347:FreeRTOS/Source/timers.c **** 		
 348:FreeRTOS/Source/timers.c **** 		/* Empty the command queue. */
 349:FreeRTOS/Source/timers.c **** 		prvProcessReceivedCommands();		
 411              		.loc 1 349 0 discriminator 1
 412 001e FFF7FEFF 		bl	prvProcessReceivedCommands
 350:FreeRTOS/Source/timers.c **** 	}
 413              		.loc 1 350 0 discriminator 1
 414 0022 F1E7     		b	.L13
 415              		.cfi_endproc
 416              	.LFE114:
 418              		.section	.text.prvProcessTimerOrBlockTask,"ax",%progbits
 419              		.align	2
 420              		.thumb
 421              		.thumb_func
 423              	prvProcessTimerOrBlockTask:
 424              	.LFB115:
 351:FreeRTOS/Source/timers.c **** }
 352:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 353:FreeRTOS/Source/timers.c **** 
 354:FreeRTOS/Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 355:FreeRTOS/Source/timers.c **** {
 425              		.loc 1 355 0
 426              		.cfi_startproc
 427              		@ args = 0, pretend = 0, frame = 16
 428              		@ frame_needed = 1, uses_anonymous_args = 0
 429 0000 80B5     		push	{r7, lr}
 430              	.LCFI15:
 431              		.cfi_def_cfa_offset 8
 432              		.cfi_offset 14, -4
 433              		.cfi_offset 7, -8
 434 0002 84B0     		sub	sp, sp, #16
 435              	.LCFI16:
 436              		.cfi_def_cfa_offset 24
 437 0004 00AF     		add	r7, sp, #0
 438              	.LCFI17:
 439              		.cfi_def_cfa_register 7
 440 0006 7860     		str	r0, [r7, #4]
 441 0008 3960     		str	r1, [r7, #0]
 356:FreeRTOS/Source/timers.c **** portTickType xTimeNow;
 357:FreeRTOS/Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched;
 358:FreeRTOS/Source/timers.c **** 
 359:FreeRTOS/Source/timers.c **** 	vTaskSuspendAll();
 442              		.loc 1 359 0
 443 000a FFF7FEFF 		bl	vTaskSuspendAll
 360:FreeRTOS/Source/timers.c **** 	{
 361:FreeRTOS/Source/timers.c **** 		/* Obtain the time now to make an assessment as to whether the timer
 362:FreeRTOS/Source/timers.c **** 		has expired or not.  If obtaining the time causes the lists to switch
 363:FreeRTOS/Source/timers.c **** 		then don't process this timer as any timers that remained in the list
 364:FreeRTOS/Source/timers.c **** 		when the lists were switched will have been processed within the
 365:FreeRTOS/Source/timers.c **** 		prvSampelTimeNow() function. */
 366:FreeRTOS/Source/timers.c **** 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 444              		.loc 1 366 0
 445 000e 07F10803 		add	r3, r7, #8
 446 0012 1846     		mov	r0, r3
 447 0014 FFF7FEFF 		bl	prvSampleTimeNow
 448 0018 F860     		str	r0, [r7, #12]
 367:FreeRTOS/Source/timers.c **** 		if( xTimerListsWereSwitched == pdFALSE )
 449              		.loc 1 367 0
 450 001a BB68     		ldr	r3, [r7, #8]
 451 001c 002B     		cmp	r3, #0
 452 001e 21D1     		bne	.L15
 368:FreeRTOS/Source/timers.c **** 		{
 369:FreeRTOS/Source/timers.c **** 			/* The tick count has not overflowed, has the timer expired? */
 370:FreeRTOS/Source/timers.c **** 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 453              		.loc 1 370 0
 454 0020 3B68     		ldr	r3, [r7, #0]
 455 0022 002B     		cmp	r3, #0
 456 0024 0AD1     		bne	.L16
 457              		.loc 1 370 0 is_stmt 0 discriminator 1
 458 0026 7A68     		ldr	r2, [r7, #4]
 459 0028 FB68     		ldr	r3, [r7, #12]
 460 002a 9A42     		cmp	r2, r3
 461 002c 06D8     		bhi	.L16
 371:FreeRTOS/Source/timers.c **** 			{
 372:FreeRTOS/Source/timers.c **** 				xTaskResumeAll();
 462              		.loc 1 372 0 is_stmt 1
 463 002e FFF7FEFF 		bl	xTaskResumeAll
 373:FreeRTOS/Source/timers.c **** 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 464              		.loc 1 373 0
 465 0032 7868     		ldr	r0, [r7, #4]
 466 0034 F968     		ldr	r1, [r7, #12]
 467 0036 FFF7FEFF 		bl	prvProcessExpiredTimer
 468 003a 17E0     		b	.L14
 469              	.L16:
 374:FreeRTOS/Source/timers.c **** 			}
 375:FreeRTOS/Source/timers.c **** 			else
 376:FreeRTOS/Source/timers.c **** 			{
 377:FreeRTOS/Source/timers.c **** 				/* The tick count has not overflowed, and the next expire
 378:FreeRTOS/Source/timers.c **** 				time has not been reached yet.  This task should therefore
 379:FreeRTOS/Source/timers.c **** 				block to wait for the next expire time or a command to be
 380:FreeRTOS/Source/timers.c **** 				received - whichever comes first.  The following line cannot
 381:FreeRTOS/Source/timers.c **** 				be reached unless xNextExpireTime > xTimeNow, except in the
 382:FreeRTOS/Source/timers.c **** 				case when the current timer list is empty. */
 383:FreeRTOS/Source/timers.c **** 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 470              		.loc 1 383 0
 471 003c 40F20003 		movw	r3, #:lower16:xTimerQueue
 472 0040 C0F20003 		movt	r3, #:upper16:xTimerQueue
 473 0044 1A68     		ldr	r2, [r3, #0]
 474 0046 7968     		ldr	r1, [r7, #4]
 475 0048 FB68     		ldr	r3, [r7, #12]
 476 004a CB1A     		subs	r3, r1, r3
 477 004c 1046     		mov	r0, r2
 478 004e 1946     		mov	r1, r3
 479 0050 FFF7FEFF 		bl	vQueueWaitForMessageRestricted
 384:FreeRTOS/Source/timers.c **** 
 385:FreeRTOS/Source/timers.c **** 				if( xTaskResumeAll() == pdFALSE )
 480              		.loc 1 385 0
 481 0054 FFF7FEFF 		bl	xTaskResumeAll
 482 0058 0346     		mov	r3, r0
 483 005a 002B     		cmp	r3, #0
 484 005c 05D1     		bne	.L19
 386:FreeRTOS/Source/timers.c **** 				{
 387:FreeRTOS/Source/timers.c **** 					/* Yield to wait for either a command to arrive, or the block time
 388:FreeRTOS/Source/timers.c **** 					to expire.  If a command arrived between the critical section being
 389:FreeRTOS/Source/timers.c **** 					exited and this yield then the yield will not cause the task
 390:FreeRTOS/Source/timers.c **** 					to block. */
 391:FreeRTOS/Source/timers.c **** 					portYIELD_WITHIN_API();
 485              		.loc 1 391 0
 486 005e FFF7FEFF 		bl	vPortYieldFromISR
 487 0062 02E0     		b	.L19
 488              	.L15:
 392:FreeRTOS/Source/timers.c **** 				}
 393:FreeRTOS/Source/timers.c **** 			}
 394:FreeRTOS/Source/timers.c **** 		}
 395:FreeRTOS/Source/timers.c **** 		else
 396:FreeRTOS/Source/timers.c **** 		{
 397:FreeRTOS/Source/timers.c **** 			xTaskResumeAll();
 489              		.loc 1 397 0
 490 0064 FFF7FEFF 		bl	xTaskResumeAll
 491 0068 00E0     		b	.L14
 492              	.L19:
 391:FreeRTOS/Source/timers.c **** 					portYIELD_WITHIN_API();
 493              		.loc 1 391 0
 494 006a 00BF     		nop
 495              	.L14:
 398:FreeRTOS/Source/timers.c **** 		}
 399:FreeRTOS/Source/timers.c **** 	}
 400:FreeRTOS/Source/timers.c **** }
 496              		.loc 1 400 0
 497 006c 07F11007 		add	r7, r7, #16
 498 0070 BD46     		mov	sp, r7
 499 0072 80BD     		pop	{r7, pc}
 500              		.cfi_endproc
 501              	.LFE115:
 503              		.section	.text.prvGetNextExpireTime,"ax",%progbits
 504              		.align	2
 505              		.thumb
 506              		.thumb_func
 508              	prvGetNextExpireTime:
 509              	.LFB116:
 401:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 402:FreeRTOS/Source/timers.c **** 
 403:FreeRTOS/Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
 404:FreeRTOS/Source/timers.c **** {
 510              		.loc 1 404 0
 511              		.cfi_startproc
 512              		@ args = 0, pretend = 0, frame = 16
 513              		@ frame_needed = 1, uses_anonymous_args = 0
 514              		@ link register save eliminated.
 515 0000 80B4     		push	{r7}
 516              	.LCFI18:
 517              		.cfi_def_cfa_offset 4
 518              		.cfi_offset 7, -4
 519 0002 85B0     		sub	sp, sp, #20
 520              	.LCFI19:
 521              		.cfi_def_cfa_offset 24
 522 0004 00AF     		add	r7, sp, #0
 523              	.LCFI20:
 524              		.cfi_def_cfa_register 7
 525 0006 7860     		str	r0, [r7, #4]
 405:FreeRTOS/Source/timers.c **** portTickType xNextExpireTime;
 406:FreeRTOS/Source/timers.c **** 
 407:FreeRTOS/Source/timers.c **** 	/* Timers are listed in expiry time order, with the head of the list
 408:FreeRTOS/Source/timers.c **** 	referencing the task that will expire first.  Obtain the time at which
 409:FreeRTOS/Source/timers.c **** 	the timer with the nearest expiry time will expire.  If there are no
 410:FreeRTOS/Source/timers.c **** 	active timers then just set the next expire time to 0.  That will cause
 411:FreeRTOS/Source/timers.c **** 	this task to unblock when the tick count overflows, at which point the
 412:FreeRTOS/Source/timers.c **** 	timer lists will be switched and the next expiry time can be
 413:FreeRTOS/Source/timers.c **** 	re-assessed.  */
 414:FreeRTOS/Source/timers.c **** 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 526              		.loc 1 414 0
 527 0008 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 528 000c C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 529 0010 1B68     		ldr	r3, [r3, #0]
 530 0012 1B68     		ldr	r3, [r3, #0]
 531 0014 002B     		cmp	r3, #0
 532 0016 14BF     		ite	ne
 533 0018 0022     		movne	r2, #0
 534 001a 0122     		moveq	r2, #1
 535 001c 7B68     		ldr	r3, [r7, #4]
 536 001e 1A60     		str	r2, [r3, #0]
 415:FreeRTOS/Source/timers.c **** 	if( *pxListWasEmpty == pdFALSE )
 537              		.loc 1 415 0
 538 0020 7B68     		ldr	r3, [r7, #4]
 539 0022 1B68     		ldr	r3, [r3, #0]
 540 0024 002B     		cmp	r3, #0
 541 0026 08D1     		bne	.L21
 416:FreeRTOS/Source/timers.c **** 	{
 417:FreeRTOS/Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 542              		.loc 1 417 0
 543 0028 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 544 002c C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 545 0030 1B68     		ldr	r3, [r3, #0]
 546 0032 DB68     		ldr	r3, [r3, #12]
 547 0034 1B68     		ldr	r3, [r3, #0]
 548 0036 FB60     		str	r3, [r7, #12]
 549 0038 02E0     		b	.L22
 550              	.L21:
 418:FreeRTOS/Source/timers.c **** 	}
 419:FreeRTOS/Source/timers.c **** 	else
 420:FreeRTOS/Source/timers.c **** 	{
 421:FreeRTOS/Source/timers.c **** 		/* Ensure the task unblocks when the tick count rolls over. */
 422:FreeRTOS/Source/timers.c **** 		xNextExpireTime = ( portTickType ) 0U;
 551              		.loc 1 422 0
 552 003a 4FF00003 		mov	r3, #0
 553 003e FB60     		str	r3, [r7, #12]
 554              	.L22:
 423:FreeRTOS/Source/timers.c **** 	}
 424:FreeRTOS/Source/timers.c **** 
 425:FreeRTOS/Source/timers.c **** 	return xNextExpireTime;
 555              		.loc 1 425 0
 556 0040 FB68     		ldr	r3, [r7, #12]
 426:FreeRTOS/Source/timers.c **** }
 557              		.loc 1 426 0
 558 0042 1846     		mov	r0, r3
 559 0044 07F11407 		add	r7, r7, #20
 560 0048 BD46     		mov	sp, r7
 561 004a 80BC     		pop	{r7}
 562 004c 7047     		bx	lr
 563              		.cfi_endproc
 564              	.LFE116:
 566 004e 00BF     		.section	.text.prvSampleTimeNow,"ax",%progbits
 567              		.align	2
 568              		.thumb
 569              		.thumb_func
 571              	prvSampleTimeNow:
 572              	.LFB117:
 427:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 428:FreeRTOS/Source/timers.c **** 
 429:FreeRTOS/Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
 430:FreeRTOS/Source/timers.c **** {
 573              		.loc 1 430 0
 574              		.cfi_startproc
 575              		@ args = 0, pretend = 0, frame = 16
 576              		@ frame_needed = 1, uses_anonymous_args = 0
 577 0000 80B5     		push	{r7, lr}
 578              	.LCFI21:
 579              		.cfi_def_cfa_offset 8
 580              		.cfi_offset 14, -4
 581              		.cfi_offset 7, -8
 582 0002 84B0     		sub	sp, sp, #16
 583              	.LCFI22:
 584              		.cfi_def_cfa_offset 24
 585 0004 00AF     		add	r7, sp, #0
 586              	.LCFI23:
 587              		.cfi_def_cfa_register 7
 588 0006 7860     		str	r0, [r7, #4]
 431:FreeRTOS/Source/timers.c **** portTickType xTimeNow;
 432:FreeRTOS/Source/timers.c **** static portTickType xLastTime = ( portTickType ) 0U;
 433:FreeRTOS/Source/timers.c **** 
 434:FreeRTOS/Source/timers.c **** 	xTimeNow = xTaskGetTickCount();
 589              		.loc 1 434 0
 590 0008 FFF7FEFF 		bl	xTaskGetTickCount
 591 000c F860     		str	r0, [r7, #12]
 435:FreeRTOS/Source/timers.c **** 	
 436:FreeRTOS/Source/timers.c **** 	if( xTimeNow < xLastTime )
 592              		.loc 1 436 0
 593 000e 40F20003 		movw	r3, #:lower16:xLastTime.7528
 594 0012 C0F20003 		movt	r3, #:upper16:xLastTime.7528
 595 0016 1B68     		ldr	r3, [r3, #0]
 596 0018 FA68     		ldr	r2, [r7, #12]
 597 001a 9A42     		cmp	r2, r3
 598 001c 0CD2     		bcs	.L24
 437:FreeRTOS/Source/timers.c **** 	{
 438:FreeRTOS/Source/timers.c **** 		prvSwitchTimerLists( xLastTime );
 599              		.loc 1 438 0
 600 001e 40F20003 		movw	r3, #:lower16:xLastTime.7528
 601 0022 C0F20003 		movt	r3, #:upper16:xLastTime.7528
 602 0026 1B68     		ldr	r3, [r3, #0]
 603 0028 1846     		mov	r0, r3
 604 002a FFF7FEFF 		bl	prvSwitchTimerLists
 439:FreeRTOS/Source/timers.c **** 		*pxTimerListsWereSwitched = pdTRUE;
 605              		.loc 1 439 0
 606 002e 7B68     		ldr	r3, [r7, #4]
 607 0030 4FF00102 		mov	r2, #1
 608 0034 1A60     		str	r2, [r3, #0]
 609 0036 03E0     		b	.L25
 610              	.L24:
 440:FreeRTOS/Source/timers.c **** 	}
 441:FreeRTOS/Source/timers.c **** 	else
 442:FreeRTOS/Source/timers.c **** 	{
 443:FreeRTOS/Source/timers.c **** 		*pxTimerListsWereSwitched = pdFALSE;
 611              		.loc 1 443 0
 612 0038 7B68     		ldr	r3, [r7, #4]
 613 003a 4FF00002 		mov	r2, #0
 614 003e 1A60     		str	r2, [r3, #0]
 615              	.L25:
 444:FreeRTOS/Source/timers.c **** 	}
 445:FreeRTOS/Source/timers.c **** 	
 446:FreeRTOS/Source/timers.c **** 	xLastTime = xTimeNow;
 616              		.loc 1 446 0
 617 0040 40F20003 		movw	r3, #:lower16:xLastTime.7528
 618 0044 C0F20003 		movt	r3, #:upper16:xLastTime.7528
 619 0048 FA68     		ldr	r2, [r7, #12]
 620 004a 1A60     		str	r2, [r3, #0]
 447:FreeRTOS/Source/timers.c **** 	
 448:FreeRTOS/Source/timers.c **** 	return xTimeNow;
 621              		.loc 1 448 0
 622 004c FB68     		ldr	r3, [r7, #12]
 449:FreeRTOS/Source/timers.c **** }
 623              		.loc 1 449 0
 624 004e 1846     		mov	r0, r3
 625 0050 07F11007 		add	r7, r7, #16
 626 0054 BD46     		mov	sp, r7
 627 0056 80BD     		pop	{r7, pc}
 628              		.cfi_endproc
 629              	.LFE117:
 631              		.section	.text.prvInsertTimerInActiveList,"ax",%progbits
 632              		.align	2
 633              		.thumb
 634              		.thumb_func
 636              	prvInsertTimerInActiveList:
 637              	.LFB118:
 450:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 451:FreeRTOS/Source/timers.c **** 
 452:FreeRTOS/Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 453:FreeRTOS/Source/timers.c **** {
 638              		.loc 1 453 0
 639              		.cfi_startproc
 640              		@ args = 0, pretend = 0, frame = 24
 641              		@ frame_needed = 1, uses_anonymous_args = 0
 642 0000 80B5     		push	{r7, lr}
 643              	.LCFI24:
 644              		.cfi_def_cfa_offset 8
 645              		.cfi_offset 14, -4
 646              		.cfi_offset 7, -8
 647 0002 86B0     		sub	sp, sp, #24
 648              	.LCFI25:
 649              		.cfi_def_cfa_offset 32
 650 0004 00AF     		add	r7, sp, #0
 651              	.LCFI26:
 652              		.cfi_def_cfa_register 7
 653 0006 F860     		str	r0, [r7, #12]
 654 0008 B960     		str	r1, [r7, #8]
 655 000a 7A60     		str	r2, [r7, #4]
 656 000c 3B60     		str	r3, [r7, #0]
 454:FreeRTOS/Source/timers.c **** portBASE_TYPE xProcessTimerNow = pdFALSE;
 657              		.loc 1 454 0
 658 000e 4FF00003 		mov	r3, #0
 659 0012 7B61     		str	r3, [r7, #20]
 455:FreeRTOS/Source/timers.c **** 
 456:FreeRTOS/Source/timers.c **** 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 660              		.loc 1 456 0
 661 0014 FB68     		ldr	r3, [r7, #12]
 662 0016 BA68     		ldr	r2, [r7, #8]
 663 0018 5A60     		str	r2, [r3, #4]
 457:FreeRTOS/Source/timers.c **** 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 664              		.loc 1 457 0
 665 001a FB68     		ldr	r3, [r7, #12]
 666 001c FA68     		ldr	r2, [r7, #12]
 667 001e 1A61     		str	r2, [r3, #16]
 458:FreeRTOS/Source/timers.c **** 	
 459:FreeRTOS/Source/timers.c **** 	if( xNextExpiryTime <= xTimeNow )
 668              		.loc 1 459 0
 669 0020 BA68     		ldr	r2, [r7, #8]
 670 0022 7B68     		ldr	r3, [r7, #4]
 671 0024 9A42     		cmp	r2, r3
 672 0026 17D8     		bhi	.L27
 460:FreeRTOS/Source/timers.c **** 	{
 461:FreeRTOS/Source/timers.c **** 		/* Has the expiry time elapsed between the command to start/reset a
 462:FreeRTOS/Source/timers.c **** 		timer was issued, and the time the command was processed? */
 463:FreeRTOS/Source/timers.c **** 		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 673              		.loc 1 463 0
 674 0028 7A68     		ldr	r2, [r7, #4]
 675 002a 3B68     		ldr	r3, [r7, #0]
 676 002c D21A     		subs	r2, r2, r3
 677 002e FB68     		ldr	r3, [r7, #12]
 678 0030 9B69     		ldr	r3, [r3, #24]
 679 0032 9A42     		cmp	r2, r3
 680 0034 03D3     		bcc	.L28
 464:FreeRTOS/Source/timers.c **** 		{
 465:FreeRTOS/Source/timers.c **** 			/* The time between a command being issued and the command being
 466:FreeRTOS/Source/timers.c **** 			processed actually exceeds the timers period.  */
 467:FreeRTOS/Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 681              		.loc 1 467 0
 682 0036 4FF00103 		mov	r3, #1
 683 003a 7B61     		str	r3, [r7, #20]
 684 003c 24E0     		b	.L29
 685              	.L28:
 468:FreeRTOS/Source/timers.c **** 		}
 469:FreeRTOS/Source/timers.c **** 		else
 470:FreeRTOS/Source/timers.c **** 		{
 471:FreeRTOS/Source/timers.c **** 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 686              		.loc 1 471 0
 687 003e 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 688 0042 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 689 0046 1A68     		ldr	r2, [r3, #0]
 690 0048 FB68     		ldr	r3, [r7, #12]
 691 004a 03F10403 		add	r3, r3, #4
 692 004e 1046     		mov	r0, r2
 693 0050 1946     		mov	r1, r3
 694 0052 FFF7FEFF 		bl	vListInsert
 695 0056 17E0     		b	.L29
 696              	.L27:
 472:FreeRTOS/Source/timers.c **** 		}
 473:FreeRTOS/Source/timers.c **** 	}
 474:FreeRTOS/Source/timers.c **** 	else
 475:FreeRTOS/Source/timers.c **** 	{
 476:FreeRTOS/Source/timers.c **** 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 697              		.loc 1 476 0
 698 0058 7A68     		ldr	r2, [r7, #4]
 699 005a 3B68     		ldr	r3, [r7, #0]
 700 005c 9A42     		cmp	r2, r3
 701 005e 07D2     		bcs	.L30
 702              		.loc 1 476 0 is_stmt 0 discriminator 1
 703 0060 BA68     		ldr	r2, [r7, #8]
 704 0062 3B68     		ldr	r3, [r7, #0]
 705 0064 9A42     		cmp	r2, r3
 706 0066 03D3     		bcc	.L30
 477:FreeRTOS/Source/timers.c **** 		{
 478:FreeRTOS/Source/timers.c **** 			/* If, since the command was issued, the tick count has overflowed
 479:FreeRTOS/Source/timers.c **** 			but the expiry time has not, then the timer must have already passed
 480:FreeRTOS/Source/timers.c **** 			its expiry time and should be processed immediately. */
 481:FreeRTOS/Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 707              		.loc 1 481 0 is_stmt 1
 708 0068 4FF00103 		mov	r3, #1
 709 006c 7B61     		str	r3, [r7, #20]
 710 006e 0BE0     		b	.L29
 711              	.L30:
 482:FreeRTOS/Source/timers.c **** 		}
 483:FreeRTOS/Source/timers.c **** 		else
 484:FreeRTOS/Source/timers.c **** 		{
 485:FreeRTOS/Source/timers.c **** 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 712              		.loc 1 485 0
 713 0070 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 714 0074 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 715 0078 1A68     		ldr	r2, [r3, #0]
 716 007a FB68     		ldr	r3, [r7, #12]
 717 007c 03F10403 		add	r3, r3, #4
 718 0080 1046     		mov	r0, r2
 719 0082 1946     		mov	r1, r3
 720 0084 FFF7FEFF 		bl	vListInsert
 721              	.L29:
 486:FreeRTOS/Source/timers.c **** 		}
 487:FreeRTOS/Source/timers.c **** 	}
 488:FreeRTOS/Source/timers.c **** 
 489:FreeRTOS/Source/timers.c **** 	return xProcessTimerNow;
 722              		.loc 1 489 0
 723 0088 7B69     		ldr	r3, [r7, #20]
 490:FreeRTOS/Source/timers.c **** }
 724              		.loc 1 490 0
 725 008a 1846     		mov	r0, r3
 726 008c 07F11807 		add	r7, r7, #24
 727 0090 BD46     		mov	sp, r7
 728 0092 80BD     		pop	{r7, pc}
 729              		.cfi_endproc
 730              	.LFE118:
 732              		.section	.text.prvProcessReceivedCommands,"ax",%progbits
 733              		.align	2
 734              		.thumb
 735              		.thumb_func
 737              	prvProcessReceivedCommands:
 738              	.LFB119:
 491:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 492:FreeRTOS/Source/timers.c **** 
 493:FreeRTOS/Source/timers.c **** static void	prvProcessReceivedCommands( void )
 494:FreeRTOS/Source/timers.c **** {
 739              		.loc 1 494 0
 740              		.cfi_startproc
 741              		@ args = 0, pretend = 0, frame = 32
 742              		@ frame_needed = 1, uses_anonymous_args = 0
 743 0000 80B5     		push	{r7, lr}
 744              	.LCFI27:
 745              		.cfi_def_cfa_offset 8
 746              		.cfi_offset 14, -4
 747              		.cfi_offset 7, -8
 748 0002 8AB0     		sub	sp, sp, #40
 749              	.LCFI28:
 750              		.cfi_def_cfa_offset 48
 751 0004 02AF     		add	r7, sp, #8
 752              	.LCFI29:
 753              		.cfi_def_cfa 7, 40
 495:FreeRTOS/Source/timers.c **** xTIMER_MESSAGE xMessage;
 496:FreeRTOS/Source/timers.c **** xTIMER *pxTimer;
 497:FreeRTOS/Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched, xResult;
 498:FreeRTOS/Source/timers.c **** portTickType xTimeNow;
 499:FreeRTOS/Source/timers.c **** 
 500:FreeRTOS/Source/timers.c **** 	/* In this case the xTimerListsWereSwitched parameter is not used, but it
 501:FreeRTOS/Source/timers.c **** 	must be present in the function call. */
 502:FreeRTOS/Source/timers.c **** 	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 754              		.loc 1 502 0
 755 0006 07F10403 		add	r3, r7, #4
 756 000a 1846     		mov	r0, r3
 757 000c FFF7FEFF 		bl	prvSampleTimeNow
 758 0010 F861     		str	r0, [r7, #28]
 503:FreeRTOS/Source/timers.c **** 
 504:FreeRTOS/Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 759              		.loc 1 504 0
 760 0012 58E0     		b	.L32
 761              	.L41:
 505:FreeRTOS/Source/timers.c **** 	{
 506:FreeRTOS/Source/timers.c **** 		pxTimer = xMessage.pxTimer;
 762              		.loc 1 506 0
 763 0014 3B69     		ldr	r3, [r7, #16]
 764 0016 BB61     		str	r3, [r7, #24]
 507:FreeRTOS/Source/timers.c **** 
 508:FreeRTOS/Source/timers.c **** 		/* Is the timer already in a list of active timers?  When the command
 509:FreeRTOS/Source/timers.c **** 		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
 510:FreeRTOS/Source/timers.c **** 		command is to the task rather than to an individual timer. */
 511:FreeRTOS/Source/timers.c **** 		if( pxTimer != NULL )
 765              		.loc 1 511 0
 766 0018 BB69     		ldr	r3, [r7, #24]
 767 001a 002B     		cmp	r3, #0
 768 001c 09D0     		beq	.L33
 512:FreeRTOS/Source/timers.c **** 		{
 513:FreeRTOS/Source/timers.c **** 			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 769              		.loc 1 513 0
 770 001e BB69     		ldr	r3, [r7, #24]
 771 0020 5B69     		ldr	r3, [r3, #20]
 772 0022 002B     		cmp	r3, #0
 773 0024 05D0     		beq	.L33
 514:FreeRTOS/Source/timers.c **** 			{
 515:FreeRTOS/Source/timers.c **** 				/* The timer is in a list, remove it. */
 516:FreeRTOS/Source/timers.c **** 				vListRemove( &( pxTimer->xTimerListItem ) );
 774              		.loc 1 516 0
 775 0026 BB69     		ldr	r3, [r7, #24]
 776 0028 03F10403 		add	r3, r3, #4
 777 002c 1846     		mov	r0, r3
 778 002e FFF7FEFF 		bl	vListRemove
 779              	.L33:
 517:FreeRTOS/Source/timers.c **** 			}
 518:FreeRTOS/Source/timers.c **** 		}
 519:FreeRTOS/Source/timers.c **** 
 520:FreeRTOS/Source/timers.c **** 		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
 521:FreeRTOS/Source/timers.c **** 		
 522:FreeRTOS/Source/timers.c **** 		switch( xMessage.xMessageID )
 780              		.loc 1 522 0
 781 0032 BB68     		ldr	r3, [r7, #8]
 782 0034 032B     		cmp	r3, #3
 783 0036 43D8     		bhi	.L42
 784 0038 01A2     		adr	r2, .L39
 785 003a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 786 003e 00BF     		.align	2
 787              	.L39:
 788 0040 51000000 		.word	.L35+1
 789 0044 C1000000 		.word	.L42+1
 790 0048 9D000000 		.word	.L37+1
 791 004c B9000000 		.word	.L38+1
 792              	.L35:
 523:FreeRTOS/Source/timers.c **** 		{
 524:FreeRTOS/Source/timers.c **** 			case tmrCOMMAND_START :	
 525:FreeRTOS/Source/timers.c **** 				/* Start or restart a timer. */
 526:FreeRTOS/Source/timers.c **** 				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks
 793              		.loc 1 526 0
 794 0050 FA68     		ldr	r2, [r7, #12]
 795 0052 BB69     		ldr	r3, [r7, #24]
 796 0054 9B69     		ldr	r3, [r3, #24]
 797 0056 D218     		adds	r2, r2, r3
 798 0058 FB68     		ldr	r3, [r7, #12]
 799 005a B869     		ldr	r0, [r7, #24]
 800 005c 1146     		mov	r1, r2
 801 005e FA69     		ldr	r2, [r7, #28]
 802 0060 FFF7FEFF 		bl	prvInsertTimerInActiveList
 803 0064 0346     		mov	r3, r0
 804 0066 012B     		cmp	r3, #1
 805 0068 2CD1     		bne	.L43
 527:FreeRTOS/Source/timers.c **** 				{
 528:FreeRTOS/Source/timers.c **** 					/* The timer expired before it was added to the active timer
 529:FreeRTOS/Source/timers.c **** 					list.  Process it now. */
 530:FreeRTOS/Source/timers.c **** 					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 806              		.loc 1 530 0
 807 006a BB69     		ldr	r3, [r7, #24]
 808 006c 5B6A     		ldr	r3, [r3, #36]
 809 006e B869     		ldr	r0, [r7, #24]
 810 0070 9847     		blx	r3
 531:FreeRTOS/Source/timers.c **** 
 532:FreeRTOS/Source/timers.c **** 					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 811              		.loc 1 532 0
 812 0072 BB69     		ldr	r3, [r7, #24]
 813 0074 DB69     		ldr	r3, [r3, #28]
 814 0076 012B     		cmp	r3, #1
 815 0078 24D1     		bne	.L43
 533:FreeRTOS/Source/timers.c **** 					{
 534:FreeRTOS/Source/timers.c **** 						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->
 816              		.loc 1 534 0
 817 007a FA68     		ldr	r2, [r7, #12]
 818 007c BB69     		ldr	r3, [r7, #24]
 819 007e 9B69     		ldr	r3, [r3, #24]
 820 0080 D318     		adds	r3, r2, r3
 821 0082 4FF00002 		mov	r2, #0
 822 0086 0092     		str	r2, [sp, #0]
 823 0088 B869     		ldr	r0, [r7, #24]
 824 008a 4FF00001 		mov	r1, #0
 825 008e 1A46     		mov	r2, r3
 826 0090 4FF00003 		mov	r3, #0
 827 0094 FFF7FEFF 		bl	xTimerGenericCommand
 828 0098 7861     		str	r0, [r7, #20]
 535:FreeRTOS/Source/timers.c **** 						configASSERT( xResult );
 536:FreeRTOS/Source/timers.c **** 						( void ) xResult;
 537:FreeRTOS/Source/timers.c **** 					}
 538:FreeRTOS/Source/timers.c **** 				}
 539:FreeRTOS/Source/timers.c **** 				break;
 829              		.loc 1 539 0
 830 009a 13E0     		b	.L43
 831              	.L37:
 540:FreeRTOS/Source/timers.c **** 
 541:FreeRTOS/Source/timers.c **** 			case tmrCOMMAND_STOP :	
 542:FreeRTOS/Source/timers.c **** 				/* The timer has already been removed from the active list.
 543:FreeRTOS/Source/timers.c **** 				There is nothing to do here. */
 544:FreeRTOS/Source/timers.c **** 				break;
 545:FreeRTOS/Source/timers.c **** 
 546:FreeRTOS/Source/timers.c **** 			case tmrCOMMAND_CHANGE_PERIOD :
 547:FreeRTOS/Source/timers.c **** 				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 832              		.loc 1 547 0
 833 009c FA68     		ldr	r2, [r7, #12]
 834 009e BB69     		ldr	r3, [r7, #24]
 835 00a0 9A61     		str	r2, [r3, #24]
 548:FreeRTOS/Source/timers.c **** 				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 549:FreeRTOS/Source/timers.c **** 				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTi
 836              		.loc 1 549 0
 837 00a2 BB69     		ldr	r3, [r7, #24]
 838 00a4 9A69     		ldr	r2, [r3, #24]
 839 00a6 FB69     		ldr	r3, [r7, #28]
 840 00a8 D318     		adds	r3, r2, r3
 841 00aa B869     		ldr	r0, [r7, #24]
 842 00ac 1946     		mov	r1, r3
 843 00ae FA69     		ldr	r2, [r7, #28]
 844 00b0 FB69     		ldr	r3, [r7, #28]
 845 00b2 FFF7FEFF 		bl	prvInsertTimerInActiveList
 550:FreeRTOS/Source/timers.c **** 				break;
 846              		.loc 1 550 0
 847 00b6 06E0     		b	.L32
 848              	.L38:
 551:FreeRTOS/Source/timers.c **** 
 552:FreeRTOS/Source/timers.c **** 			case tmrCOMMAND_DELETE :
 553:FreeRTOS/Source/timers.c **** 				/* The timer has already been removed from the active list,
 554:FreeRTOS/Source/timers.c **** 				just free up the memory. */
 555:FreeRTOS/Source/timers.c **** 				vPortFree( pxTimer );
 849              		.loc 1 555 0
 850 00b8 B869     		ldr	r0, [r7, #24]
 851 00ba FFF7FEFF 		bl	free
 556:FreeRTOS/Source/timers.c **** 				break;
 852              		.loc 1 556 0
 853 00be 02E0     		b	.L32
 854              	.L42:
 557:FreeRTOS/Source/timers.c **** 
 558:FreeRTOS/Source/timers.c **** 			default	:			
 559:FreeRTOS/Source/timers.c **** 				/* Don't expect to get here. */
 560:FreeRTOS/Source/timers.c **** 				break;
 855              		.loc 1 560 0
 856 00c0 00BF     		nop
 857 00c2 00E0     		b	.L32
 858              	.L43:
 539:FreeRTOS/Source/timers.c **** 				break;
 859              		.loc 1 539 0
 860 00c4 00BF     		nop
 861              	.L32:
 504:FreeRTOS/Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 862              		.loc 1 504 0 discriminator 1
 863 00c6 40F20003 		movw	r3, #:lower16:xTimerQueue
 864 00ca C0F20003 		movt	r3, #:upper16:xTimerQueue
 865 00ce 1B68     		ldr	r3, [r3, #0]
 866 00d0 1846     		mov	r0, r3
 867 00d2 07F10803 		add	r3, r7, #8
 868 00d6 1946     		mov	r1, r3
 869 00d8 4FF00002 		mov	r2, #0
 870 00dc 4FF00003 		mov	r3, #0
 871 00e0 FFF7FEFF 		bl	xQueueGenericReceive
 872 00e4 0346     		mov	r3, r0
 873 00e6 002B     		cmp	r3, #0
 874 00e8 94D1     		bne	.L41
 561:FreeRTOS/Source/timers.c **** 		}
 562:FreeRTOS/Source/timers.c **** 	}
 563:FreeRTOS/Source/timers.c **** }
 875              		.loc 1 563 0
 876 00ea 07F12007 		add	r7, r7, #32
 877 00ee BD46     		mov	sp, r7
 878 00f0 80BD     		pop	{r7, pc}
 879              		.cfi_endproc
 880              	.LFE119:
 882 00f2 00BF     		.section	.text.prvSwitchTimerLists,"ax",%progbits
 883              		.align	2
 884              		.thumb
 885              		.thumb_func
 887              	prvSwitchTimerLists:
 888              	.LFB120:
 564:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 565:FreeRTOS/Source/timers.c **** 
 566:FreeRTOS/Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime )
 567:FreeRTOS/Source/timers.c **** {
 889              		.loc 1 567 0
 890              		.cfi_startproc
 891              		@ args = 0, pretend = 0, frame = 32
 892              		@ frame_needed = 1, uses_anonymous_args = 0
 893 0000 80B5     		push	{r7, lr}
 894              	.LCFI30:
 895              		.cfi_def_cfa_offset 8
 896              		.cfi_offset 14, -4
 897              		.cfi_offset 7, -8
 898 0002 8AB0     		sub	sp, sp, #40
 899              	.LCFI31:
 900              		.cfi_def_cfa_offset 48
 901 0004 02AF     		add	r7, sp, #8
 902              	.LCFI32:
 903              		.cfi_def_cfa 7, 40
 904 0006 7860     		str	r0, [r7, #4]
 568:FreeRTOS/Source/timers.c **** portTickType xNextExpireTime, xReloadTime;
 569:FreeRTOS/Source/timers.c **** xList *pxTemp;
 570:FreeRTOS/Source/timers.c **** xTIMER *pxTimer;
 571:FreeRTOS/Source/timers.c **** portBASE_TYPE xResult;
 572:FreeRTOS/Source/timers.c **** 
 573:FreeRTOS/Source/timers.c **** 	/* Remove compiler warnings if configASSERT() is not defined. */
 574:FreeRTOS/Source/timers.c **** 	( void ) xLastTime;
 575:FreeRTOS/Source/timers.c **** 	
 576:FreeRTOS/Source/timers.c **** 	/* The tick count has overflowed.  The timer lists must be switched.
 577:FreeRTOS/Source/timers.c **** 	If there are any timers still referenced from the current timer list
 578:FreeRTOS/Source/timers.c **** 	then they must have expired and should be processed before the lists
 579:FreeRTOS/Source/timers.c **** 	are switched. */
 580:FreeRTOS/Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 905              		.loc 1 580 0
 906 0008 45E0     		b	.L45
 907              	.L47:
 581:FreeRTOS/Source/timers.c **** 	{
 582:FreeRTOS/Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 908              		.loc 1 582 0
 909 000a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 910 000e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 911 0012 1B68     		ldr	r3, [r3, #0]
 912 0014 DB68     		ldr	r3, [r3, #12]
 913 0016 1B68     		ldr	r3, [r3, #0]
 914 0018 FB61     		str	r3, [r7, #28]
 583:FreeRTOS/Source/timers.c **** 
 584:FreeRTOS/Source/timers.c **** 		/* Remove the timer from the list. */
 585:FreeRTOS/Source/timers.c **** 		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 915              		.loc 1 585 0
 916 001a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 917 001e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 918 0022 1B68     		ldr	r3, [r3, #0]
 919 0024 DB68     		ldr	r3, [r3, #12]
 920 0026 DB68     		ldr	r3, [r3, #12]
 921 0028 BB61     		str	r3, [r7, #24]
 586:FreeRTOS/Source/timers.c **** 		vListRemove( &( pxTimer->xTimerListItem ) );
 922              		.loc 1 586 0
 923 002a BB69     		ldr	r3, [r7, #24]
 924 002c 03F10403 		add	r3, r3, #4
 925 0030 1846     		mov	r0, r3
 926 0032 FFF7FEFF 		bl	vListRemove
 587:FreeRTOS/Source/timers.c **** 
 588:FreeRTOS/Source/timers.c **** 		/* Execute its callback, then send a command to restart the timer if
 589:FreeRTOS/Source/timers.c **** 		it is an auto-reload timer.  It cannot be restarted here as the lists
 590:FreeRTOS/Source/timers.c **** 		have not yet been switched. */
 591:FreeRTOS/Source/timers.c **** 		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 927              		.loc 1 591 0
 928 0036 BB69     		ldr	r3, [r7, #24]
 929 0038 5B6A     		ldr	r3, [r3, #36]
 930 003a B869     		ldr	r0, [r7, #24]
 931 003c 9847     		blx	r3
 592:FreeRTOS/Source/timers.c **** 
 593:FreeRTOS/Source/timers.c **** 		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 932              		.loc 1 593 0
 933 003e BB69     		ldr	r3, [r7, #24]
 934 0040 DB69     		ldr	r3, [r3, #28]
 935 0042 012B     		cmp	r3, #1
 936 0044 27D1     		bne	.L45
 594:FreeRTOS/Source/timers.c **** 		{
 595:FreeRTOS/Source/timers.c **** 			/* Calculate the reload value, and if the reload value results in
 596:FreeRTOS/Source/timers.c **** 			the timer going into the same timer list then it has already expired
 597:FreeRTOS/Source/timers.c **** 			and the timer should be re-inserted into the current list so it is
 598:FreeRTOS/Source/timers.c **** 			processed again within this loop.  Otherwise a command should be sent
 599:FreeRTOS/Source/timers.c **** 			to restart the timer to ensure it is only inserted into a list after
 600:FreeRTOS/Source/timers.c **** 			the lists have been swapped. */
 601:FreeRTOS/Source/timers.c **** 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 937              		.loc 1 601 0
 938 0046 BB69     		ldr	r3, [r7, #24]
 939 0048 9A69     		ldr	r2, [r3, #24]
 940 004a FB69     		ldr	r3, [r7, #28]
 941 004c D318     		adds	r3, r2, r3
 942 004e 7B61     		str	r3, [r7, #20]
 602:FreeRTOS/Source/timers.c **** 			if( xReloadTime > xNextExpireTime )
 943              		.loc 1 602 0
 944 0050 7A69     		ldr	r2, [r7, #20]
 945 0052 FB69     		ldr	r3, [r7, #28]
 946 0054 9A42     		cmp	r2, r3
 947 0056 12D9     		bls	.L46
 603:FreeRTOS/Source/timers.c **** 			{
 604:FreeRTOS/Source/timers.c **** 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 948              		.loc 1 604 0
 949 0058 BB69     		ldr	r3, [r7, #24]
 950 005a 7A69     		ldr	r2, [r7, #20]
 951 005c 5A60     		str	r2, [r3, #4]
 605:FreeRTOS/Source/timers.c **** 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 952              		.loc 1 605 0
 953 005e BB69     		ldr	r3, [r7, #24]
 954 0060 BA69     		ldr	r2, [r7, #24]
 955 0062 1A61     		str	r2, [r3, #16]
 606:FreeRTOS/Source/timers.c **** 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 956              		.loc 1 606 0
 957 0064 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 958 0068 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 959 006c 1A68     		ldr	r2, [r3, #0]
 960 006e BB69     		ldr	r3, [r7, #24]
 961 0070 03F10403 		add	r3, r3, #4
 962 0074 1046     		mov	r0, r2
 963 0076 1946     		mov	r1, r3
 964 0078 FFF7FEFF 		bl	vListInsert
 965 007c 0BE0     		b	.L45
 966              	.L46:
 607:FreeRTOS/Source/timers.c **** 			}
 608:FreeRTOS/Source/timers.c **** 			else
 609:FreeRTOS/Source/timers.c **** 			{
 610:FreeRTOS/Source/timers.c **** 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY )
 967              		.loc 1 610 0
 968 007e 4FF00003 		mov	r3, #0
 969 0082 0093     		str	r3, [sp, #0]
 970 0084 B869     		ldr	r0, [r7, #24]
 971 0086 4FF00001 		mov	r1, #0
 972 008a FA69     		ldr	r2, [r7, #28]
 973 008c 4FF00003 		mov	r3, #0
 974 0090 FFF7FEFF 		bl	xTimerGenericCommand
 975 0094 3861     		str	r0, [r7, #16]
 976              	.L45:
 580:FreeRTOS/Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 977              		.loc 1 580 0 discriminator 1
 978 0096 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 979 009a C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 980 009e 1B68     		ldr	r3, [r3, #0]
 981 00a0 1B68     		ldr	r3, [r3, #0]
 982 00a2 002B     		cmp	r3, #0
 983 00a4 B1D1     		bne	.L47
 611:FreeRTOS/Source/timers.c **** 				configASSERT( xResult );
 612:FreeRTOS/Source/timers.c **** 				( void ) xResult;
 613:FreeRTOS/Source/timers.c **** 			}
 614:FreeRTOS/Source/timers.c **** 		}
 615:FreeRTOS/Source/timers.c **** 	}
 616:FreeRTOS/Source/timers.c **** 
 617:FreeRTOS/Source/timers.c **** 	pxTemp = pxCurrentTimerList;
 984              		.loc 1 617 0
 985 00a6 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 986 00aa C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 987 00ae 1B68     		ldr	r3, [r3, #0]
 988 00b0 FB60     		str	r3, [r7, #12]
 618:FreeRTOS/Source/timers.c **** 	pxCurrentTimerList = pxOverflowTimerList;
 989              		.loc 1 618 0
 990 00b2 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 991 00b6 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 992 00ba 1A68     		ldr	r2, [r3, #0]
 993 00bc 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 994 00c0 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 995 00c4 1A60     		str	r2, [r3, #0]
 619:FreeRTOS/Source/timers.c **** 	pxOverflowTimerList = pxTemp;
 996              		.loc 1 619 0
 997 00c6 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 998 00ca C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 999 00ce FA68     		ldr	r2, [r7, #12]
 1000 00d0 1A60     		str	r2, [r3, #0]
 620:FreeRTOS/Source/timers.c **** }
 1001              		.loc 1 620 0
 1002 00d2 07F12007 		add	r7, r7, #32
 1003 00d6 BD46     		mov	sp, r7
 1004 00d8 80BD     		pop	{r7, pc}
 1005              		.cfi_endproc
 1006              	.LFE120:
 1008 00da 00BF     		.section	.text.prvCheckForValidListAndQueue,"ax",%progbits
 1009              		.align	2
 1010              		.thumb
 1011              		.thumb_func
 1013              	prvCheckForValidListAndQueue:
 1014              	.LFB121:
 621:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 622:FreeRTOS/Source/timers.c **** 
 623:FreeRTOS/Source/timers.c **** static void prvCheckForValidListAndQueue( void )
 624:FreeRTOS/Source/timers.c **** {
 1015              		.loc 1 624 0
 1016              		.cfi_startproc
 1017              		@ args = 0, pretend = 0, frame = 0
 1018              		@ frame_needed = 1, uses_anonymous_args = 0
 1019 0000 80B5     		push	{r7, lr}
 1020              	.LCFI33:
 1021              		.cfi_def_cfa_offset 8
 1022              		.cfi_offset 14, -4
 1023              		.cfi_offset 7, -8
 1024 0002 00AF     		add	r7, sp, #0
 1025              	.LCFI34:
 1026              		.cfi_def_cfa_register 7
 625:FreeRTOS/Source/timers.c **** 	/* Check that the list from which active timers are referenced, and the
 626:FreeRTOS/Source/timers.c **** 	queue used to communicate with the timer service, have been
 627:FreeRTOS/Source/timers.c **** 	initialised. */
 628:FreeRTOS/Source/timers.c **** 	taskENTER_CRITICAL();
 1027              		.loc 1 628 0
 1028 0004 FFF7FEFF 		bl	vPortEnterCritical
 629:FreeRTOS/Source/timers.c **** 	{
 630:FreeRTOS/Source/timers.c **** 		if( xTimerQueue == NULL )
 1029              		.loc 1 630 0
 1030 0008 40F20003 		movw	r3, #:lower16:xTimerQueue
 1031 000c C0F20003 		movt	r3, #:upper16:xTimerQueue
 1032 0010 1B68     		ldr	r3, [r3, #0]
 1033 0012 002B     		cmp	r3, #0
 1034 0014 29D1     		bne	.L49
 631:FreeRTOS/Source/timers.c **** 		{
 632:FreeRTOS/Source/timers.c **** 			vListInitialise( &xActiveTimerList1 );
 1035              		.loc 1 632 0
 1036 0016 40F20000 		movw	r0, #:lower16:xActiveTimerList1
 1037 001a C0F20000 		movt	r0, #:upper16:xActiveTimerList1
 1038 001e FFF7FEFF 		bl	vListInitialise
 633:FreeRTOS/Source/timers.c **** 			vListInitialise( &xActiveTimerList2 );
 1039              		.loc 1 633 0
 1040 0022 40F20000 		movw	r0, #:lower16:xActiveTimerList2
 1041 0026 C0F20000 		movt	r0, #:upper16:xActiveTimerList2
 1042 002a FFF7FEFF 		bl	vListInitialise
 634:FreeRTOS/Source/timers.c **** 			pxCurrentTimerList = &xActiveTimerList1;
 1043              		.loc 1 634 0
 1044 002e 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1045 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1046 0036 40F20002 		movw	r2, #:lower16:xActiveTimerList1
 1047 003a C0F20002 		movt	r2, #:upper16:xActiveTimerList1
 1048 003e 1A60     		str	r2, [r3, #0]
 635:FreeRTOS/Source/timers.c **** 			pxOverflowTimerList = &xActiveTimerList2;
 1049              		.loc 1 635 0
 1050 0040 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1051 0044 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1052 0048 40F20002 		movw	r2, #:lower16:xActiveTimerList2
 1053 004c C0F20002 		movt	r2, #:upper16:xActiveTimerList2
 1054 0050 1A60     		str	r2, [r3, #0]
 636:FreeRTOS/Source/timers.c **** 			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_
 1055              		.loc 1 636 0
 1056 0052 4FF00A00 		mov	r0, #10
 1057 0056 4FF00C01 		mov	r1, #12
 1058 005a FFF7FEFF 		bl	xQueueCreate
 1059 005e 0246     		mov	r2, r0
 1060 0060 40F20003 		movw	r3, #:lower16:xTimerQueue
 1061 0064 C0F20003 		movt	r3, #:upper16:xTimerQueue
 1062 0068 1A60     		str	r2, [r3, #0]
 1063              	.L49:
 637:FreeRTOS/Source/timers.c **** 		}
 638:FreeRTOS/Source/timers.c **** 	}
 639:FreeRTOS/Source/timers.c **** 	taskEXIT_CRITICAL();
 1064              		.loc 1 639 0
 1065 006a FFF7FEFF 		bl	vPortExitCritical
 640:FreeRTOS/Source/timers.c **** }
 1066              		.loc 1 640 0
 1067 006e 80BD     		pop	{r7, pc}
 1068              		.cfi_endproc
 1069              	.LFE121:
 1071              		.section	.text.xTimerIsTimerActive,"ax",%progbits
 1072              		.align	2
 1073              		.global	xTimerIsTimerActive
 1074              		.thumb
 1075              		.thumb_func
 1077              	xTimerIsTimerActive:
 1078              	.LFB122:
 641:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 642:FreeRTOS/Source/timers.c **** 
 643:FreeRTOS/Source/timers.c **** portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
 644:FreeRTOS/Source/timers.c **** {
 1079              		.loc 1 644 0
 1080              		.cfi_startproc
 1081              		@ args = 0, pretend = 0, frame = 16
 1082              		@ frame_needed = 1, uses_anonymous_args = 0
 1083 0000 80B5     		push	{r7, lr}
 1084              	.LCFI35:
 1085              		.cfi_def_cfa_offset 8
 1086              		.cfi_offset 14, -4
 1087              		.cfi_offset 7, -8
 1088 0002 84B0     		sub	sp, sp, #16
 1089              	.LCFI36:
 1090              		.cfi_def_cfa_offset 24
 1091 0004 00AF     		add	r7, sp, #0
 1092              	.LCFI37:
 1093              		.cfi_def_cfa_register 7
 1094 0006 7860     		str	r0, [r7, #4]
 645:FreeRTOS/Source/timers.c **** portBASE_TYPE xTimerIsInActiveList;
 646:FreeRTOS/Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1095              		.loc 1 646 0
 1096 0008 7B68     		ldr	r3, [r7, #4]
 1097 000a FB60     		str	r3, [r7, #12]
 647:FreeRTOS/Source/timers.c **** 
 648:FreeRTOS/Source/timers.c **** 	/* Is the timer in the list of active timers? */
 649:FreeRTOS/Source/timers.c **** 	taskENTER_CRITICAL();
 1098              		.loc 1 649 0
 1099 000c FFF7FEFF 		bl	vPortEnterCritical
 650:FreeRTOS/Source/timers.c **** 	{
 651:FreeRTOS/Source/timers.c **** 		/* Checking to see if it is in the NULL list in effect checks to see if
 652:FreeRTOS/Source/timers.c **** 		it is referenced from either the current or the overflow timer lists in
 653:FreeRTOS/Source/timers.c **** 		one go, but the logic has to be reversed, hence the '!'. */
 654:FreeRTOS/Source/timers.c **** 		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 1100              		.loc 1 654 0
 1101 0010 FB68     		ldr	r3, [r7, #12]
 1102 0012 5B69     		ldr	r3, [r3, #20]
 1103 0014 002B     		cmp	r3, #0
 1104 0016 0CBF     		ite	eq
 1105 0018 0023     		moveq	r3, #0
 1106 001a 0123     		movne	r3, #1
 1107 001c BB60     		str	r3, [r7, #8]
 655:FreeRTOS/Source/timers.c **** 	}
 656:FreeRTOS/Source/timers.c **** 	taskEXIT_CRITICAL();
 1108              		.loc 1 656 0
 1109 001e FFF7FEFF 		bl	vPortExitCritical
 657:FreeRTOS/Source/timers.c **** 
 658:FreeRTOS/Source/timers.c **** 	return xTimerIsInActiveList;
 1110              		.loc 1 658 0
 1111 0022 BB68     		ldr	r3, [r7, #8]
 659:FreeRTOS/Source/timers.c **** }
 1112              		.loc 1 659 0
 1113 0024 1846     		mov	r0, r3
 1114 0026 07F11007 		add	r7, r7, #16
 1115 002a BD46     		mov	sp, r7
 1116 002c 80BD     		pop	{r7, pc}
 1117              		.cfi_endproc
 1118              	.LFE122:
 1120 002e 00BF     		.section	.text.pvTimerGetTimerID,"ax",%progbits
 1121              		.align	2
 1122              		.global	pvTimerGetTimerID
 1123              		.thumb
 1124              		.thumb_func
 1126              	pvTimerGetTimerID:
 1127              	.LFB123:
 660:FreeRTOS/Source/timers.c **** /*-----------------------------------------------------------*/
 661:FreeRTOS/Source/timers.c **** 
 662:FreeRTOS/Source/timers.c **** void *pvTimerGetTimerID( xTimerHandle xTimer )
 663:FreeRTOS/Source/timers.c **** {
 1128              		.loc 1 663 0
 1129              		.cfi_startproc
 1130              		@ args = 0, pretend = 0, frame = 16
 1131              		@ frame_needed = 1, uses_anonymous_args = 0
 1132              		@ link register save eliminated.
 1133 0000 80B4     		push	{r7}
 1134              	.LCFI38:
 1135              		.cfi_def_cfa_offset 4
 1136              		.cfi_offset 7, -4
 1137 0002 85B0     		sub	sp, sp, #20
 1138              	.LCFI39:
 1139              		.cfi_def_cfa_offset 24
 1140 0004 00AF     		add	r7, sp, #0
 1141              	.LCFI40:
 1142              		.cfi_def_cfa_register 7
 1143 0006 7860     		str	r0, [r7, #4]
 664:FreeRTOS/Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1144              		.loc 1 664 0
 1145 0008 7B68     		ldr	r3, [r7, #4]
 1146 000a FB60     		str	r3, [r7, #12]
 665:FreeRTOS/Source/timers.c **** 
 666:FreeRTOS/Source/timers.c **** 	return pxTimer->pvTimerID;
 1147              		.loc 1 666 0
 1148 000c FB68     		ldr	r3, [r7, #12]
 1149 000e 1B6A     		ldr	r3, [r3, #32]
 667:FreeRTOS/Source/timers.c **** }
 1150              		.loc 1 667 0
 1151 0010 1846     		mov	r0, r3
 1152 0012 07F11407 		add	r7, r7, #20
 1153 0016 BD46     		mov	sp, r7
 1154 0018 80BC     		pop	{r7}
 1155 001a 7047     		bx	lr
 1156              		.cfi_endproc
 1157              	.LFE123:
 1159              		.section	.bss.xLastTime.7528,"aw",%nobits
 1160              		.align	2
 1163              	xLastTime.7528:
 1164 0000 00000000 		.space	4
 1165              		.text
 1166              	.Letext0:
 1167              		.file 2 "/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/../../../../arm-none-eabi/i
 1168              		.file 3 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 1169              		.file 4 "FreeRTOS/Source/include/list.h"
 1170              		.file 5 "FreeRTOS/Source/include/queue.h"
 1171              		.file 6 "FreeRTOS/Source/include/timers.h"
 1172              		.file 7 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
     /tmp/ccVmODAe.s:20     .bss.xActiveTimerList1:00000000 $d
     /tmp/ccVmODAe.s:23     .bss.xActiveTimerList1:00000000 xActiveTimerList1
     /tmp/ccVmODAe.s:26     .bss.xActiveTimerList2:00000000 $d
     /tmp/ccVmODAe.s:29     .bss.xActiveTimerList2:00000000 xActiveTimerList2
     /tmp/ccVmODAe.s:32     .bss.pxCurrentTimerList:00000000 $d
     /tmp/ccVmODAe.s:35     .bss.pxCurrentTimerList:00000000 pxCurrentTimerList
     /tmp/ccVmODAe.s:38     .bss.pxOverflowTimerList:00000000 $d
     /tmp/ccVmODAe.s:41     .bss.pxOverflowTimerList:00000000 pxOverflowTimerList
     /tmp/ccVmODAe.s:44     .bss.xTimerQueue:00000000 $d
     /tmp/ccVmODAe.s:47     .bss.xTimerQueue:00000000 xTimerQueue
     /tmp/ccVmODAe.s:50     .rodata:00000000 $d
     /tmp/ccVmODAe.s:51     .rodata:00000000 .LC0
     /tmp/ccVmODAe.s:54     .text.xTimerCreateTimerTask:00000000 $t
     /tmp/ccVmODAe.s:59     .text.xTimerCreateTimerTask:00000000 xTimerCreateTimerTask
     /tmp/ccVmODAe.s:1013   .text.prvCheckForValidListAndQueue:00000000 prvCheckForValidListAndQueue
     /tmp/ccVmODAe.s:382    .text.prvTimerTask:00000000 prvTimerTask
     /tmp/ccVmODAe.s:117    .text.xTimerCreate:00000000 $t
     /tmp/ccVmODAe.s:122    .text.xTimerCreate:00000000 xTimerCreate
     /tmp/ccVmODAe.s:200    .text.xTimerGenericCommand:00000000 $t
     /tmp/ccVmODAe.s:205    .text.xTimerGenericCommand:00000000 xTimerGenericCommand
     /tmp/ccVmODAe.s:302    .text.prvProcessExpiredTimer:00000000 $t
     /tmp/ccVmODAe.s:306    .text.prvProcessExpiredTimer:00000000 prvProcessExpiredTimer
     /tmp/ccVmODAe.s:636    .text.prvInsertTimerInActiveList:00000000 prvInsertTimerInActiveList
     /tmp/ccVmODAe.s:378    .text.prvTimerTask:00000000 $t
     /tmp/ccVmODAe.s:508    .text.prvGetNextExpireTime:00000000 prvGetNextExpireTime
     /tmp/ccVmODAe.s:423    .text.prvProcessTimerOrBlockTask:00000000 prvProcessTimerOrBlockTask
     /tmp/ccVmODAe.s:737    .text.prvProcessReceivedCommands:00000000 prvProcessReceivedCommands
     /tmp/ccVmODAe.s:419    .text.prvProcessTimerOrBlockTask:00000000 $t
     /tmp/ccVmODAe.s:571    .text.prvSampleTimeNow:00000000 prvSampleTimeNow
     /tmp/ccVmODAe.s:504    .text.prvGetNextExpireTime:00000000 $t
     /tmp/ccVmODAe.s:567    .text.prvSampleTimeNow:00000000 $t
     /tmp/ccVmODAe.s:1163   .bss.xLastTime.7528:00000000 xLastTime.7528
     /tmp/ccVmODAe.s:887    .text.prvSwitchTimerLists:00000000 prvSwitchTimerLists
     /tmp/ccVmODAe.s:632    .text.prvInsertTimerInActiveList:00000000 $t
     /tmp/ccVmODAe.s:733    .text.prvProcessReceivedCommands:00000000 $t
     /tmp/ccVmODAe.s:788    .text.prvProcessReceivedCommands:00000040 $d
     /tmp/ccVmODAe.s:794    .text.prvProcessReceivedCommands:00000050 $t
     /tmp/ccVmODAe.s:883    .text.prvSwitchTimerLists:00000000 $t
     /tmp/ccVmODAe.s:1009   .text.prvCheckForValidListAndQueue:00000000 $t
     /tmp/ccVmODAe.s:1072   .text.xTimerIsTimerActive:00000000 $t
     /tmp/ccVmODAe.s:1077   .text.xTimerIsTimerActive:00000000 xTimerIsTimerActive
     /tmp/ccVmODAe.s:1121   .text.pvTimerGetTimerID:00000000 $t
     /tmp/ccVmODAe.s:1126   .text.pvTimerGetTimerID:00000000 pvTimerGetTimerID
     /tmp/ccVmODAe.s:1160   .bss.xLastTime.7528:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xTaskGenericCreate
malloc
vListInitialiseItem
xTaskGetSchedulerState
xQueueGenericSend
xQueueGenericSendFromISR
vListRemove
vTaskSuspendAll
xTaskResumeAll
vQueueWaitForMessageRestricted
vPortYieldFromISR
xTaskGetTickCount
vListInsert
free
xQueueGenericReceive
vPortEnterCritical
vListInitialise
xQueueCreate
vPortExitCritical
