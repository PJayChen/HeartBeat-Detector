   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.xQueueCreate,"ax",%progbits
  20              		.align	2
  21              		.global	xQueueCreate
  22              		.thumb
  23              		.thumb_func
  25              	xQueueCreate:
  26              	.LFB110:
  27              		.file 1 "FreeRTOS/Source/queue.c"
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/queue.c **** 
   4:FreeRTOS/Source/queue.c **** 
   5:FreeRTOS/Source/queue.c ****     ***************************************************************************
   6:FreeRTOS/Source/queue.c ****      *                                                                       *
   7:FreeRTOS/Source/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/queue.c ****      *    available.                                                         *
  10:FreeRTOS/Source/queue.c ****      *                                                                       *
  11:FreeRTOS/Source/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/queue.c ****      *                                                                       *
  18:FreeRTOS/Source/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/queue.c ****      *                                                                       *
  20:FreeRTOS/Source/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/queue.c ****      *                                                                       *
  22:FreeRTOS/Source/queue.c ****     ***************************************************************************
  23:FreeRTOS/Source/queue.c **** 
  24:FreeRTOS/Source/queue.c **** 
  25:FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/queue.c **** 
  27:FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/queue.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/queue.c **** 
  42:FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/queue.c **** 
  44:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/queue.c ****     contact details.
  46:FreeRTOS/Source/queue.c **** 
  47:FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/queue.c ****     critical systems.
  49:FreeRTOS/Source/queue.c **** 
  50:FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/queue.c ****     licensing and training services.
  52:FreeRTOS/Source/queue.c **** */
  53:FreeRTOS/Source/queue.c **** 
  54:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  55:FreeRTOS/Source/queue.c **** #include <string.h>
  56:FreeRTOS/Source/queue.c **** 
  57:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  60:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:FreeRTOS/Source/queue.c **** 
  62:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  63:FreeRTOS/Source/queue.c **** #include "task.h"
  64:FreeRTOS/Source/queue.c **** 
  65:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  67:FreeRTOS/Source/queue.c **** #endif
  68:FreeRTOS/Source/queue.c **** 
  69:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:FreeRTOS/Source/queue.c **** 
  71:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
  72:FreeRTOS/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  73:FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
  74:FreeRTOS/Source/queue.c **** 
  75:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:FreeRTOS/Source/queue.c **** 
  79:FreeRTOS/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:FreeRTOS/Source/queue.c **** 
  81:FreeRTOS/Source/queue.c **** /* For internal use only. */
  82:FreeRTOS/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:FreeRTOS/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:FreeRTOS/Source/queue.c **** 
  85:FreeRTOS/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
  87:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  88:FreeRTOS/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:FreeRTOS/Source/queue.c **** 
  91:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:FreeRTOS/Source/queue.c **** zero. */
  93:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:FreeRTOS/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:FreeRTOS/Source/queue.c **** 
  97:FreeRTOS/Source/queue.c **** /*
  98:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  99:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.
 100:FreeRTOS/Source/queue.c ****  */
 101:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 102:FreeRTOS/Source/queue.c **** {
 103:FreeRTOS/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 104:FreeRTOS/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 105:FreeRTOS/Source/queue.c **** 
 106:FreeRTOS/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 107:FreeRTOS/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 108:FreeRTOS/Source/queue.c **** 
 109:FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 110:FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 111:FreeRTOS/Source/queue.c **** 
 112:FreeRTOS/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 113:FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 114:FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 115:FreeRTOS/Source/queue.c **** 
 116:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 117:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 118:FreeRTOS/Source/queue.c **** 
 119:FreeRTOS/Source/queue.c **** } xQUEUE;
 120:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 121:FreeRTOS/Source/queue.c **** 
 122:FreeRTOS/Source/queue.c **** /*
 123:FreeRTOS/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 124:FreeRTOS/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 125:FreeRTOS/Source/queue.c ****  * pointer to void.
 126:FreeRTOS/Source/queue.c ****  */
 127:FreeRTOS/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 128:FreeRTOS/Source/queue.c **** 
 129:FreeRTOS/Source/queue.c **** /*
 130:FreeRTOS/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 131:FreeRTOS/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 132:FreeRTOS/Source/queue.c ****  * functions are documented in the API header file.
 133:FreeRTOS/Source/queue.c ****  */
 134:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 135:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 136:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 137:FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 138:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 139:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 140:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 141:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 142:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 143:FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 144:FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 145:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 146:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 147:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 148:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 150:FreeRTOS/Source/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 151:FreeRTOS/Source/queue.c **** 
 152:FreeRTOS/Source/queue.c **** /*
 153:FreeRTOS/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 154:FreeRTOS/Source/queue.c ****  * an optional component.
 155:FreeRTOS/Source/queue.c ****  */
 156:FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 157:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 158:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 159:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 160:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 161:FreeRTOS/Source/queue.c **** #endif
 162:FreeRTOS/Source/queue.c **** 
 163:FreeRTOS/Source/queue.c **** /*
 164:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 165:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 166:FreeRTOS/Source/queue.c ****  */
 167:FreeRTOS/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 168:FreeRTOS/Source/queue.c **** 
 169:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 170:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 171:FreeRTOS/Source/queue.c **** 	more user friendly. */
 172:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 173:FreeRTOS/Source/queue.c **** 	{
 174:FreeRTOS/Source/queue.c **** 		signed char *pcQueueName;
 175:FreeRTOS/Source/queue.c **** 		xQueueHandle xHandle;
 176:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 177:FreeRTOS/Source/queue.c **** 
 178:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 179:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 180:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 181:FreeRTOS/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 184:FreeRTOS/Source/queue.c **** 	member to NULL. */
 185:FreeRTOS/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 186:FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 187:FreeRTOS/Source/queue.c **** #endif
 188:FreeRTOS/Source/queue.c **** 
 189:FreeRTOS/Source/queue.c **** /*
 190:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 191:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 192:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 193:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 194:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 195:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 196:FreeRTOS/Source/queue.c ****  */
 197:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 198:FreeRTOS/Source/queue.c **** 
 199:FreeRTOS/Source/queue.c **** /*
 200:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 201:FreeRTOS/Source/queue.c ****  *
 202:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 203:FreeRTOS/Source/queue.c ****  */
 204:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 205:FreeRTOS/Source/queue.c **** 
 206:FreeRTOS/Source/queue.c **** /*
 207:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 208:FreeRTOS/Source/queue.c ****  *
 209:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 210:FreeRTOS/Source/queue.c ****  */
 211:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 212:FreeRTOS/Source/queue.c **** 
 213:FreeRTOS/Source/queue.c **** /*
 214:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 215:FreeRTOS/Source/queue.c ****  * back of the queue.
 216:FreeRTOS/Source/queue.c ****  */
 217:FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 218:FreeRTOS/Source/queue.c **** 
 219:FreeRTOS/Source/queue.c **** /*
 220:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 221:FreeRTOS/Source/queue.c ****  */
 222:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 223:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 224:FreeRTOS/Source/queue.c **** 
 225:FreeRTOS/Source/queue.c **** /*
 226:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 227:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 228:FreeRTOS/Source/queue.c ****  */
 229:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 230:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 231:FreeRTOS/Source/queue.c **** 	{														\
 232:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 233:FreeRTOS/Source/queue.c **** 		{													\
 234:FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 235:FreeRTOS/Source/queue.c **** 		}													\
 236:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 237:FreeRTOS/Source/queue.c **** 		{													\
 238:FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 239:FreeRTOS/Source/queue.c **** 		}													\
 240:FreeRTOS/Source/queue.c **** 	}														\
 241:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 242:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 243:FreeRTOS/Source/queue.c **** 
 244:FreeRTOS/Source/queue.c **** 
 245:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
 246:FreeRTOS/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 247:FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
 248:FreeRTOS/Source/queue.c **** 
 249:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 250:FreeRTOS/Source/queue.c **** {
  28              		.loc 1 250 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 24
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 14, -4
  36              		.cfi_offset 7, -8
  37 0002 86B0     		sub	sp, sp, #24
  38              	.LCFI1:
  39              		.cfi_def_cfa_offset 32
  40 0004 00AF     		add	r7, sp, #0
  41              	.LCFI2:
  42              		.cfi_def_cfa_register 7
  43 0006 7860     		str	r0, [r7, #4]
  44 0008 3960     		str	r1, [r7, #0]
 251:FreeRTOS/Source/queue.c **** xQUEUE *pxNewQueue;
 252:FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 253:FreeRTOS/Source/queue.c **** xQueueHandle xReturn = NULL;
  45              		.loc 1 253 0
  46 000a 4FF00003 		mov	r3, #0
  47 000e 7B61     		str	r3, [r7, #20]
 254:FreeRTOS/Source/queue.c **** 
 255:FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure. */
 256:FreeRTOS/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  48              		.loc 1 256 0
  49 0010 7B68     		ldr	r3, [r7, #4]
  50 0012 002B     		cmp	r3, #0
  51 0014 56D0     		beq	.L2
 257:FreeRTOS/Source/queue.c **** 	{
 258:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  52              		.loc 1 258 0
  53 0016 4FF04C00 		mov	r0, #76
  54 001a FFF7FEFF 		bl	malloc
  55 001e 0346     		mov	r3, r0
  56 0020 3B61     		str	r3, [r7, #16]
 259:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
  57              		.loc 1 259 0
  58 0022 3B69     		ldr	r3, [r7, #16]
  59 0024 002B     		cmp	r3, #0
  60 0026 4DD0     		beq	.L2
 260:FreeRTOS/Source/queue.c **** 		{
 261:FreeRTOS/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 262:FreeRTOS/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 263:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  61              		.loc 1 263 0
  62 0028 7B68     		ldr	r3, [r7, #4]
  63 002a 3A68     		ldr	r2, [r7, #0]
  64 002c 02FB03F3 		mul	r3, r2, r3
  65 0030 03F10103 		add	r3, r3, #1
  66 0034 FB60     		str	r3, [r7, #12]
 264:FreeRTOS/Source/queue.c **** 
 265:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  67              		.loc 1 265 0
  68 0036 F868     		ldr	r0, [r7, #12]
  69 0038 FFF7FEFF 		bl	malloc
  70 003c 0346     		mov	r3, r0
  71 003e 1A46     		mov	r2, r3
  72 0040 3B69     		ldr	r3, [r7, #16]
  73 0042 1A60     		str	r2, [r3, #0]
 266:FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
  74              		.loc 1 266 0
  75 0044 3B69     		ldr	r3, [r7, #16]
  76 0046 1B68     		ldr	r3, [r3, #0]
  77 0048 002B     		cmp	r3, #0
  78 004a 38D0     		beq	.L3
 267:FreeRTOS/Source/queue.c **** 			{
 268:FreeRTOS/Source/queue.c **** 				/* Initialise the queue members as described above where the
 269:FreeRTOS/Source/queue.c **** 				queue type is defined. */
 270:FreeRTOS/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  79              		.loc 1 270 0
  80 004c 3B69     		ldr	r3, [r7, #16]
  81 004e 1A68     		ldr	r2, [r3, #0]
  82 0050 7B68     		ldr	r3, [r7, #4]
  83 0052 3968     		ldr	r1, [r7, #0]
  84 0054 01FB03F3 		mul	r3, r1, r3
  85 0058 D218     		adds	r2, r2, r3
  86 005a 3B69     		ldr	r3, [r7, #16]
  87 005c 5A60     		str	r2, [r3, #4]
 271:FreeRTOS/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  88              		.loc 1 271 0
  89 005e 3B69     		ldr	r3, [r7, #16]
  90 0060 4FF00002 		mov	r2, #0
  91 0064 9A63     		str	r2, [r3, #56]
 272:FreeRTOS/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
  92              		.loc 1 272 0
  93 0066 3B69     		ldr	r3, [r7, #16]
  94 0068 1A68     		ldr	r2, [r3, #0]
  95 006a 3B69     		ldr	r3, [r7, #16]
  96 006c 9A60     		str	r2, [r3, #8]
 273:FreeRTOS/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
  97              		.loc 1 273 0
  98 006e 3B69     		ldr	r3, [r7, #16]
  99 0070 1A68     		ldr	r2, [r3, #0]
 100 0072 7B68     		ldr	r3, [r7, #4]
 101 0074 03F1FF33 		add	r3, r3, #-1
 102 0078 3968     		ldr	r1, [r7, #0]
 103 007a 01FB03F3 		mul	r3, r1, r3
 104 007e D218     		adds	r2, r2, r3
 105 0080 3B69     		ldr	r3, [r7, #16]
 106 0082 DA60     		str	r2, [r3, #12]
 274:FreeRTOS/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 107              		.loc 1 274 0
 108 0084 3B69     		ldr	r3, [r7, #16]
 109 0086 7A68     		ldr	r2, [r7, #4]
 110 0088 DA63     		str	r2, [r3, #60]
 275:FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 111              		.loc 1 275 0
 112 008a 3B69     		ldr	r3, [r7, #16]
 113 008c 3A68     		ldr	r2, [r7, #0]
 114 008e 1A64     		str	r2, [r3, #64]
 276:FreeRTOS/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 115              		.loc 1 276 0
 116 0090 3B69     		ldr	r3, [r7, #16]
 117 0092 4FF0FF32 		mov	r2, #-1
 118 0096 5A64     		str	r2, [r3, #68]
 277:FreeRTOS/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 119              		.loc 1 277 0
 120 0098 3B69     		ldr	r3, [r7, #16]
 121 009a 4FF0FF32 		mov	r2, #-1
 122 009e 9A64     		str	r2, [r3, #72]
 278:FreeRTOS/Source/queue.c **** 
 279:FreeRTOS/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 280:FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 123              		.loc 1 280 0
 124 00a0 3B69     		ldr	r3, [r7, #16]
 125 00a2 03F11003 		add	r3, r3, #16
 126 00a6 1846     		mov	r0, r3
 127 00a8 FFF7FEFF 		bl	vListInitialise
 281:FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 128              		.loc 1 281 0
 129 00ac 3B69     		ldr	r3, [r7, #16]
 130 00ae 03F12403 		add	r3, r3, #36
 131 00b2 1846     		mov	r0, r3
 132 00b4 FFF7FEFF 		bl	vListInitialise
 282:FreeRTOS/Source/queue.c **** 
 283:FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 284:FreeRTOS/Source/queue.c **** 				xReturn = pxNewQueue;
 133              		.loc 1 284 0
 134 00b8 3B69     		ldr	r3, [r7, #16]
 135 00ba 7B61     		str	r3, [r7, #20]
 136 00bc 02E0     		b	.L2
 137              	.L3:
 285:FreeRTOS/Source/queue.c **** 			}
 286:FreeRTOS/Source/queue.c **** 			else
 287:FreeRTOS/Source/queue.c **** 			{
 288:FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 289:FreeRTOS/Source/queue.c **** 				vPortFree( pxNewQueue );
 138              		.loc 1 289 0
 139 00be 3869     		ldr	r0, [r7, #16]
 140 00c0 FFF7FEFF 		bl	free
 141              	.L2:
 290:FreeRTOS/Source/queue.c **** 			}
 291:FreeRTOS/Source/queue.c **** 		}
 292:FreeRTOS/Source/queue.c **** 	}
 293:FreeRTOS/Source/queue.c **** 
 294:FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 295:FreeRTOS/Source/queue.c **** 
 296:FreeRTOS/Source/queue.c **** 	return xReturn;
 142              		.loc 1 296 0
 143 00c4 7B69     		ldr	r3, [r7, #20]
 297:FreeRTOS/Source/queue.c **** }
 144              		.loc 1 297 0
 145 00c6 1846     		mov	r0, r3
 146 00c8 07F11807 		add	r7, r7, #24
 147 00cc BD46     		mov	sp, r7
 148 00ce 80BD     		pop	{r7, pc}
 149              		.cfi_endproc
 150              	.LFE110:
 152              		.section	.text.xQueueCreateMutex,"ax",%progbits
 153              		.align	2
 154              		.global	xQueueCreateMutex
 155              		.thumb
 156              		.thumb_func
 158              	xQueueCreateMutex:
 159              	.LFB111:
 298:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 299:FreeRTOS/Source/queue.c **** 
 300:FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 301:FreeRTOS/Source/queue.c **** 
 302:FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 303:FreeRTOS/Source/queue.c **** 	{
 160              		.loc 1 303 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 8
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164 0000 80B5     		push	{r7, lr}
 165              	.LCFI3:
 166              		.cfi_def_cfa_offset 8
 167              		.cfi_offset 14, -4
 168              		.cfi_offset 7, -8
 169 0002 82B0     		sub	sp, sp, #8
 170              	.LCFI4:
 171              		.cfi_def_cfa_offset 16
 172 0004 00AF     		add	r7, sp, #0
 173              	.LCFI5:
 174              		.cfi_def_cfa_register 7
 304:FreeRTOS/Source/queue.c **** 	xQUEUE *pxNewQueue;
 305:FreeRTOS/Source/queue.c **** 
 306:FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 307:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 175              		.loc 1 307 0
 176 0006 4FF04C00 		mov	r0, #76
 177 000a FFF7FEFF 		bl	malloc
 178 000e 0346     		mov	r3, r0
 179 0010 7B60     		str	r3, [r7, #4]
 308:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 180              		.loc 1 308 0
 181 0012 7B68     		ldr	r3, [r7, #4]
 182 0014 002B     		cmp	r3, #0
 183 0016 38D0     		beq	.L5
 309:FreeRTOS/Source/queue.c **** 		{
 310:FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 311:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 184              		.loc 1 311 0
 185 0018 7B68     		ldr	r3, [r7, #4]
 186 001a 4FF00002 		mov	r2, #0
 187 001e 5A60     		str	r2, [r3, #4]
 312:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 188              		.loc 1 312 0
 189 0020 7B68     		ldr	r3, [r7, #4]
 190 0022 4FF00002 		mov	r2, #0
 191 0026 1A60     		str	r2, [r3, #0]
 313:FreeRTOS/Source/queue.c **** 
 314:FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 315:FreeRTOS/Source/queue.c **** 			of the queue. */
 316:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 192              		.loc 1 316 0
 193 0028 7B68     		ldr	r3, [r7, #4]
 194 002a 4FF00002 		mov	r2, #0
 195 002e 9A60     		str	r2, [r3, #8]
 317:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 196              		.loc 1 317 0
 197 0030 7B68     		ldr	r3, [r7, #4]
 198 0032 4FF00002 		mov	r2, #0
 199 0036 DA60     		str	r2, [r3, #12]
 318:FreeRTOS/Source/queue.c **** 
 319:FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 320:FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 321:FreeRTOS/Source/queue.c **** 			of the mutex. */
 322:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 200              		.loc 1 322 0
 201 0038 7B68     		ldr	r3, [r7, #4]
 202 003a 4FF00002 		mov	r2, #0
 203 003e 9A63     		str	r2, [r3, #56]
 323:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 204              		.loc 1 323 0
 205 0040 7B68     		ldr	r3, [r7, #4]
 206 0042 4FF00102 		mov	r2, #1
 207 0046 DA63     		str	r2, [r3, #60]
 324:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 208              		.loc 1 324 0
 209 0048 7B68     		ldr	r3, [r7, #4]
 210 004a 4FF00002 		mov	r2, #0
 211 004e 1A64     		str	r2, [r3, #64]
 325:FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 212              		.loc 1 325 0
 213 0050 7B68     		ldr	r3, [r7, #4]
 214 0052 4FF0FF32 		mov	r2, #-1
 215 0056 5A64     		str	r2, [r3, #68]
 326:FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 216              		.loc 1 326 0
 217 0058 7B68     		ldr	r3, [r7, #4]
 218 005a 4FF0FF32 		mov	r2, #-1
 219 005e 9A64     		str	r2, [r3, #72]
 327:FreeRTOS/Source/queue.c **** 
 328:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 329:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 220              		.loc 1 329 0
 221 0060 7B68     		ldr	r3, [r7, #4]
 222 0062 03F11003 		add	r3, r3, #16
 223 0066 1846     		mov	r0, r3
 224 0068 FFF7FEFF 		bl	vListInitialise
 330:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 225              		.loc 1 330 0
 226 006c 7B68     		ldr	r3, [r7, #4]
 227 006e 03F12403 		add	r3, r3, #36
 228 0072 1846     		mov	r0, r3
 229 0074 FFF7FEFF 		bl	vListInitialise
 331:FreeRTOS/Source/queue.c **** 
 332:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 333:FreeRTOS/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 230              		.loc 1 333 0
 231 0078 7868     		ldr	r0, [r7, #4]
 232 007a 4FF00001 		mov	r1, #0
 233 007e 4FF00002 		mov	r2, #0
 234 0082 4FF00003 		mov	r3, #0
 235 0086 FFF7FEFF 		bl	xQueueGenericSend
 236              	.L5:
 334:FreeRTOS/Source/queue.c **** 
 335:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 336:FreeRTOS/Source/queue.c **** 		}
 337:FreeRTOS/Source/queue.c **** 		else
 338:FreeRTOS/Source/queue.c **** 		{
 339:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 340:FreeRTOS/Source/queue.c **** 		}
 341:FreeRTOS/Source/queue.c **** 
 342:FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 343:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 237              		.loc 1 343 0
 238 008a 7B68     		ldr	r3, [r7, #4]
 344:FreeRTOS/Source/queue.c **** 	}
 239              		.loc 1 344 0
 240 008c 1846     		mov	r0, r3
 241 008e 07F10807 		add	r7, r7, #8
 242 0092 BD46     		mov	sp, r7
 243 0094 80BD     		pop	{r7, pc}
 244              		.cfi_endproc
 245              	.LFE111:
 247 0096 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 248              		.align	2
 249              		.global	xQueueGenericSend
 250              		.thumb
 251              		.thumb_func
 253              	xQueueGenericSend:
 254              	.LFB112:
 345:FreeRTOS/Source/queue.c **** 
 346:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 347:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 348:FreeRTOS/Source/queue.c **** 
 349:FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 350:FreeRTOS/Source/queue.c **** 
 351:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 352:FreeRTOS/Source/queue.c **** 	{
 353:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 354:FreeRTOS/Source/queue.c **** 
 355:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 356:FreeRTOS/Source/queue.c **** 
 357:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 358:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 359:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 360:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 361:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 362:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 363:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 364:FreeRTOS/Source/queue.c **** 		{
 365:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 366:FreeRTOS/Source/queue.c **** 
 367:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 368:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 369:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 370:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 371:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 372:FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 373:FreeRTOS/Source/queue.c **** 
 374:FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 375:FreeRTOS/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 376:FreeRTOS/Source/queue.c **** 			{
 377:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 378:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 379:FreeRTOS/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 380:FreeRTOS/Source/queue.c **** 			}
 381:FreeRTOS/Source/queue.c **** 
 382:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 383:FreeRTOS/Source/queue.c **** 		}
 384:FreeRTOS/Source/queue.c **** 		else
 385:FreeRTOS/Source/queue.c **** 		{
 386:FreeRTOS/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 387:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 388:FreeRTOS/Source/queue.c **** 
 389:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 390:FreeRTOS/Source/queue.c **** 		}
 391:FreeRTOS/Source/queue.c **** 
 392:FreeRTOS/Source/queue.c **** 		return xReturn;
 393:FreeRTOS/Source/queue.c **** 	}
 394:FreeRTOS/Source/queue.c **** 
 395:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 396:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 397:FreeRTOS/Source/queue.c **** 
 398:FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 399:FreeRTOS/Source/queue.c **** 
 400:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 401:FreeRTOS/Source/queue.c **** 	{
 402:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 403:FreeRTOS/Source/queue.c **** 
 404:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 405:FreeRTOS/Source/queue.c **** 
 406:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 407:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 408:FreeRTOS/Source/queue.c **** 
 409:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 410:FreeRTOS/Source/queue.c **** 
 411:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 412:FreeRTOS/Source/queue.c **** 		{
 413:FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 414:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 415:FreeRTOS/Source/queue.c **** 		}
 416:FreeRTOS/Source/queue.c **** 		else
 417:FreeRTOS/Source/queue.c **** 		{
 418:FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 419:FreeRTOS/Source/queue.c **** 
 420:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 421:FreeRTOS/Source/queue.c **** 			we may have blocked to reach here. */
 422:FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 423:FreeRTOS/Source/queue.c **** 			{
 424:FreeRTOS/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 425:FreeRTOS/Source/queue.c **** 			}
 426:FreeRTOS/Source/queue.c **** 			else
 427:FreeRTOS/Source/queue.c **** 			{
 428:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 429:FreeRTOS/Source/queue.c **** 			}
 430:FreeRTOS/Source/queue.c **** 		}
 431:FreeRTOS/Source/queue.c **** 
 432:FreeRTOS/Source/queue.c **** 		return xReturn;
 433:FreeRTOS/Source/queue.c **** 	}
 434:FreeRTOS/Source/queue.c **** 
 435:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 436:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 437:FreeRTOS/Source/queue.c **** 
 438:FreeRTOS/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 439:FreeRTOS/Source/queue.c **** 
 440:FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 441:FreeRTOS/Source/queue.c **** 	{
 442:FreeRTOS/Source/queue.c **** 	xQueueHandle pxHandle;
 443:FreeRTOS/Source/queue.c **** 
 444:FreeRTOS/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 445:FreeRTOS/Source/queue.c **** 
 446:FreeRTOS/Source/queue.c **** 		if( pxHandle != NULL )
 447:FreeRTOS/Source/queue.c **** 		{
 448:FreeRTOS/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 449:FreeRTOS/Source/queue.c **** 
 450:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 451:FreeRTOS/Source/queue.c **** 		}
 452:FreeRTOS/Source/queue.c **** 		else
 453:FreeRTOS/Source/queue.c **** 		{
 454:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 455:FreeRTOS/Source/queue.c **** 		}
 456:FreeRTOS/Source/queue.c **** 
 457:FreeRTOS/Source/queue.c **** 		configASSERT( pxHandle );
 458:FreeRTOS/Source/queue.c **** 		return pxHandle;
 459:FreeRTOS/Source/queue.c **** 	}
 460:FreeRTOS/Source/queue.c **** 
 461:FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 462:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 463:FreeRTOS/Source/queue.c **** 
 464:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 465:FreeRTOS/Source/queue.c **** {
 255              		.loc 1 465 0
 256              		.cfi_startproc
 257              		@ args = 0, pretend = 0, frame = 32
 258              		@ frame_needed = 1, uses_anonymous_args = 0
 259 0000 80B5     		push	{r7, lr}
 260              	.LCFI6:
 261              		.cfi_def_cfa_offset 8
 262              		.cfi_offset 14, -4
 263              		.cfi_offset 7, -8
 264 0002 88B0     		sub	sp, sp, #32
 265              	.LCFI7:
 266              		.cfi_def_cfa_offset 40
 267 0004 00AF     		add	r7, sp, #0
 268              	.LCFI8:
 269              		.cfi_def_cfa_register 7
 270 0006 F860     		str	r0, [r7, #12]
 271 0008 B960     		str	r1, [r7, #8]
 272 000a 7A60     		str	r2, [r7, #4]
 273 000c 3B60     		str	r3, [r7, #0]
 466:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 274              		.loc 1 466 0
 275 000e 4FF00003 		mov	r3, #0
 276 0012 FB61     		str	r3, [r7, #28]
 277 0014 00E0     		b	.L17
 278              	.L18:
 467:FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 468:FreeRTOS/Source/queue.c **** 
 469:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 470:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 471:FreeRTOS/Source/queue.c **** 
 472:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 473:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 474:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 475:FreeRTOS/Source/queue.c **** 	for( ;; )
 476:FreeRTOS/Source/queue.c **** 	{
 477:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 478:FreeRTOS/Source/queue.c **** 		{
 479:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 480:FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 481:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 482:FreeRTOS/Source/queue.c **** 			{
 483:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 484:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 485:FreeRTOS/Source/queue.c **** 
 486:FreeRTOS/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 487:FreeRTOS/Source/queue.c **** 				queue then unblock it now. */
 488:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 489:FreeRTOS/Source/queue.c **** 				{
 490:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 491:FreeRTOS/Source/queue.c **** 					{
 492:FreeRTOS/Source/queue.c **** 						/* The unblocked task has a priority higher than
 493:FreeRTOS/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 494:FreeRTOS/Source/queue.c **** 						this from within the critical section - the kernel
 495:FreeRTOS/Source/queue.c **** 						takes care of that. */
 496:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 497:FreeRTOS/Source/queue.c **** 					}
 498:FreeRTOS/Source/queue.c **** 				}
 499:FreeRTOS/Source/queue.c **** 
 500:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 501:FreeRTOS/Source/queue.c **** 
 502:FreeRTOS/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 503:FreeRTOS/Source/queue.c **** 				function. */
 504:FreeRTOS/Source/queue.c **** 				return pdPASS;
 505:FreeRTOS/Source/queue.c **** 			}
 506:FreeRTOS/Source/queue.c **** 			else
 507:FreeRTOS/Source/queue.c **** 			{
 508:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 509:FreeRTOS/Source/queue.c **** 				{
 510:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 511:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 512:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 513:FreeRTOS/Source/queue.c **** 
 514:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 515:FreeRTOS/Source/queue.c **** 					the function. */
 516:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 517:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 518:FreeRTOS/Source/queue.c **** 				}
 519:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 520:FreeRTOS/Source/queue.c **** 				{
 521:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 522:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 523:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 524:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 525:FreeRTOS/Source/queue.c **** 				}
 526:FreeRTOS/Source/queue.c **** 			}
 527:FreeRTOS/Source/queue.c **** 		}
 528:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 529:FreeRTOS/Source/queue.c **** 
 530:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 531:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 532:FreeRTOS/Source/queue.c **** 
 533:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 535:FreeRTOS/Source/queue.c **** 
 536:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 537:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 538:FreeRTOS/Source/queue.c **** 		{
 539:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 540:FreeRTOS/Source/queue.c **** 			{
 541:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 542:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 543:FreeRTOS/Source/queue.c **** 
 544:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 545:FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 546:FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 547:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 548:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 549:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 550:FreeRTOS/Source/queue.c **** 
 551:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 552:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 553:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 554:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 555:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 556:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 557:FreeRTOS/Source/queue.c **** 				{
 558:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 559:FreeRTOS/Source/queue.c **** 				}
 560:FreeRTOS/Source/queue.c **** 			}
 561:FreeRTOS/Source/queue.c **** 			else
 562:FreeRTOS/Source/queue.c **** 			{
 563:FreeRTOS/Source/queue.c **** 				/* Try again. */
 564:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 565:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 566:FreeRTOS/Source/queue.c **** 			}
 567:FreeRTOS/Source/queue.c **** 		}
 568:FreeRTOS/Source/queue.c **** 		else
 569:FreeRTOS/Source/queue.c **** 		{
 570:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 571:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 572:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 573:FreeRTOS/Source/queue.c **** 
 574:FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 575:FreeRTOS/Source/queue.c **** 			function. */
 576:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 577:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 578:FreeRTOS/Source/queue.c **** 		}
 579:FreeRTOS/Source/queue.c **** 	}
 279              		.loc 1 579 0
 280 0016 00BF     		nop
 281              	.L17:
 477:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 282              		.loc 1 477 0
 283 0018 FFF7FEFF 		bl	vPortEnterCritical
 481:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 284              		.loc 1 481 0
 285 001c FB68     		ldr	r3, [r7, #12]
 286 001e 9A6B     		ldr	r2, [r3, #56]
 287 0020 FB68     		ldr	r3, [r7, #12]
 288 0022 DB6B     		ldr	r3, [r3, #60]
 289 0024 9A42     		cmp	r2, r3
 290 0026 18D2     		bcs	.L7
 484:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 291              		.loc 1 484 0
 292 0028 F868     		ldr	r0, [r7, #12]
 293 002a B968     		ldr	r1, [r7, #8]
 294 002c 3A68     		ldr	r2, [r7, #0]
 295 002e FFF7FEFF 		bl	prvCopyDataToQueue
 488:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 296              		.loc 1 488 0
 297 0032 FB68     		ldr	r3, [r7, #12]
 298 0034 5B6A     		ldr	r3, [r3, #36]
 299 0036 002B     		cmp	r3, #0
 300 0038 0AD0     		beq	.L8
 490:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 301              		.loc 1 490 0
 302 003a FB68     		ldr	r3, [r7, #12]
 303 003c 03F12403 		add	r3, r3, #36
 304 0040 1846     		mov	r0, r3
 305 0042 FFF7FEFF 		bl	xTaskRemoveFromEventList
 306 0046 0346     		mov	r3, r0
 307 0048 012B     		cmp	r3, #1
 308 004a 01D1     		bne	.L8
 496:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 309              		.loc 1 496 0
 310 004c FFF7FEFF 		bl	vPortYieldFromISR
 311              	.L8:
 500:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 312              		.loc 1 500 0
 313 0050 FFF7FEFF 		bl	vPortExitCritical
 504:FreeRTOS/Source/queue.c **** 				return pdPASS;
 314              		.loc 1 504 0
 315 0054 4FF00103 		mov	r3, #1
 316 0058 5DE0     		b	.L9
 317              	.L7:
 508:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 318              		.loc 1 508 0
 319 005a 7B68     		ldr	r3, [r7, #4]
 320 005c 002B     		cmp	r3, #0
 321 005e 04D1     		bne	.L10
 512:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 322              		.loc 1 512 0
 323 0060 FFF7FEFF 		bl	vPortExitCritical
 517:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 324              		.loc 1 517 0
 325 0064 4FF00003 		mov	r3, #0
 326 0068 55E0     		b	.L9
 327              	.L10:
 519:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 328              		.loc 1 519 0
 329 006a FB69     		ldr	r3, [r7, #28]
 330 006c 002B     		cmp	r3, #0
 331 006e 07D1     		bne	.L11
 523:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 332              		.loc 1 523 0
 333 0070 07F11403 		add	r3, r7, #20
 334 0074 1846     		mov	r0, r3
 335 0076 FFF7FEFF 		bl	vTaskSetTimeOutState
 524:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 336              		.loc 1 524 0
 337 007a 4FF00103 		mov	r3, #1
 338 007e FB61     		str	r3, [r7, #28]
 339              	.L11:
 528:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 340              		.loc 1 528 0
 341 0080 FFF7FEFF 		bl	vPortExitCritical
 533:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 342              		.loc 1 533 0
 343 0084 FFF7FEFF 		bl	vTaskSuspendAll
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 344              		.loc 1 534 0
 345 0088 FFF7FEFF 		bl	vPortEnterCritical
 346 008c FB68     		ldr	r3, [r7, #12]
 347 008e 5B6C     		ldr	r3, [r3, #68]
 348 0090 B3F1FF3F 		cmp	r3, #-1
 349 0094 03D1     		bne	.L12
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 350              		.loc 1 534 0 is_stmt 0 discriminator 1
 351 0096 FB68     		ldr	r3, [r7, #12]
 352 0098 4FF00002 		mov	r2, #0
 353 009c 5A64     		str	r2, [r3, #68]
 354              	.L12:
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 355              		.loc 1 534 0 discriminator 2
 356 009e FB68     		ldr	r3, [r7, #12]
 357 00a0 9B6C     		ldr	r3, [r3, #72]
 358 00a2 B3F1FF3F 		cmp	r3, #-1
 359 00a6 03D1     		bne	.L13
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 360              		.loc 1 534 0 discriminator 3
 361 00a8 FB68     		ldr	r3, [r7, #12]
 362 00aa 4FF00002 		mov	r2, #0
 363 00ae 9A64     		str	r2, [r3, #72]
 364              	.L13:
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 365              		.loc 1 534 0 discriminator 4
 366 00b0 FFF7FEFF 		bl	vPortExitCritical
 537:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 367              		.loc 1 537 0 is_stmt 1 discriminator 4
 368 00b4 07F11403 		add	r3, r7, #20
 369 00b8 1846     		mov	r0, r3
 370 00ba 07F10403 		add	r3, r7, #4
 371 00be 1946     		mov	r1, r3
 372 00c0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 373 00c4 0346     		mov	r3, r0
 374 00c6 002B     		cmp	r3, #0
 375 00c8 1ED1     		bne	.L14
 539:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 376              		.loc 1 539 0
 377 00ca F868     		ldr	r0, [r7, #12]
 378 00cc FFF7FEFF 		bl	prvIsQueueFull
 379 00d0 0346     		mov	r3, r0
 380 00d2 002B     		cmp	r3, #0
 381 00d4 12D0     		beq	.L15
 542:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 382              		.loc 1 542 0
 383 00d6 FB68     		ldr	r3, [r7, #12]
 384 00d8 03F11002 		add	r2, r3, #16
 385 00dc 7B68     		ldr	r3, [r7, #4]
 386 00de 1046     		mov	r0, r2
 387 00e0 1946     		mov	r1, r3
 388 00e2 FFF7FEFF 		bl	vTaskPlaceOnEventList
 549:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 389              		.loc 1 549 0
 390 00e6 F868     		ldr	r0, [r7, #12]
 391 00e8 FFF7FEFF 		bl	prvUnlockQueue
 556:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 392              		.loc 1 556 0
 393 00ec FFF7FEFF 		bl	xTaskResumeAll
 394 00f0 0346     		mov	r3, r0
 395 00f2 002B     		cmp	r3, #0
 396 00f4 8FD1     		bne	.L18
 558:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 397              		.loc 1 558 0
 398 00f6 FFF7FEFF 		bl	vPortYieldFromISR
 399              		.loc 1 579 0
 400 00fa 8CE7     		b	.L18
 401              	.L15:
 564:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 402              		.loc 1 564 0
 403 00fc F868     		ldr	r0, [r7, #12]
 404 00fe FFF7FEFF 		bl	prvUnlockQueue
 565:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 405              		.loc 1 565 0
 406 0102 FFF7FEFF 		bl	xTaskResumeAll
 407              		.loc 1 579 0
 408 0106 86E7     		b	.L18
 409              	.L14:
 571:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 410              		.loc 1 571 0
 411 0108 F868     		ldr	r0, [r7, #12]
 412 010a FFF7FEFF 		bl	prvUnlockQueue
 572:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 413              		.loc 1 572 0
 414 010e FFF7FEFF 		bl	xTaskResumeAll
 577:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 415              		.loc 1 577 0
 416 0112 4FF00003 		mov	r3, #0
 417              	.L9:
 580:FreeRTOS/Source/queue.c **** }
 418              		.loc 1 580 0
 419 0116 1846     		mov	r0, r3
 420 0118 07F12007 		add	r7, r7, #32
 421 011c BD46     		mov	sp, r7
 422 011e 80BD     		pop	{r7, pc}
 423              		.cfi_endproc
 424              	.LFE112:
 426              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 427              		.align	2
 428              		.global	xQueueGenericSendFromISR
 429              		.thumb
 430              		.thumb_func
 432              	xQueueGenericSendFromISR:
 433              	.LFB113:
 581:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 582:FreeRTOS/Source/queue.c **** 
 583:FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 584:FreeRTOS/Source/queue.c **** 
 585:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 586:FreeRTOS/Source/queue.c **** 	{
 587:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 588:FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 589:FreeRTOS/Source/queue.c **** 
 590:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 591:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 592:FreeRTOS/Source/queue.c **** 
 593:FreeRTOS/Source/queue.c **** 		for( ;; )
 594:FreeRTOS/Source/queue.c **** 		{
 595:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 596:FreeRTOS/Source/queue.c **** 			{
 597:FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 598:FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 599:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 600:FreeRTOS/Source/queue.c **** 				{
 601:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 602:FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 603:FreeRTOS/Source/queue.c **** 
 604:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 605:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 606:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 607:FreeRTOS/Source/queue.c **** 					{
 608:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 609:FreeRTOS/Source/queue.c **** 						{
 610:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 611:FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 612:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 613:FreeRTOS/Source/queue.c **** 						}
 614:FreeRTOS/Source/queue.c **** 					}
 615:FreeRTOS/Source/queue.c **** 
 616:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 617:FreeRTOS/Source/queue.c **** 					return pdPASS;
 618:FreeRTOS/Source/queue.c **** 				}
 619:FreeRTOS/Source/queue.c **** 				else
 620:FreeRTOS/Source/queue.c **** 				{
 621:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 622:FreeRTOS/Source/queue.c **** 					{
 623:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 624:FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 625:FreeRTOS/Source/queue.c **** 					}
 626:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 627:FreeRTOS/Source/queue.c **** 					{
 628:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 629:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 630:FreeRTOS/Source/queue.c **** 					}
 631:FreeRTOS/Source/queue.c **** 				}
 632:FreeRTOS/Source/queue.c **** 			}
 633:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 634:FreeRTOS/Source/queue.c **** 
 635:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 636:FreeRTOS/Source/queue.c **** 			{
 637:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 638:FreeRTOS/Source/queue.c **** 				{
 639:FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 640:FreeRTOS/Source/queue.c **** 					{
 641:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 642:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 643:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 644:FreeRTOS/Source/queue.c **** 					}
 645:FreeRTOS/Source/queue.c **** 				}
 646:FreeRTOS/Source/queue.c **** 				else
 647:FreeRTOS/Source/queue.c **** 				{
 648:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 649:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 650:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 651:FreeRTOS/Source/queue.c **** 				}
 652:FreeRTOS/Source/queue.c **** 			}
 653:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 654:FreeRTOS/Source/queue.c **** 		}
 655:FreeRTOS/Source/queue.c **** 	}
 656:FreeRTOS/Source/queue.c **** 
 657:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 658:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 659:FreeRTOS/Source/queue.c **** 
 660:FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 661:FreeRTOS/Source/queue.c **** 
 662:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 663:FreeRTOS/Source/queue.c **** 	{
 664:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 665:FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 666:FreeRTOS/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 667:FreeRTOS/Source/queue.c **** 
 668:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 669:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 670:FreeRTOS/Source/queue.c **** 
 671:FreeRTOS/Source/queue.c **** 		for( ;; )
 672:FreeRTOS/Source/queue.c **** 		{
 673:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 674:FreeRTOS/Source/queue.c **** 			{
 675:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 676:FreeRTOS/Source/queue.c **** 				{
 677:FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 678:FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 679:FreeRTOS/Source/queue.c **** 
 680:FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 681:FreeRTOS/Source/queue.c **** 
 682:FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 683:FreeRTOS/Source/queue.c **** 					{
 684:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 685:FreeRTOS/Source/queue.c **** 
 686:FreeRTOS/Source/queue.c **** 						/* We are actually removing data. */
 687:FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 688:FreeRTOS/Source/queue.c **** 
 689:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 690:FreeRTOS/Source/queue.c **** 						{
 691:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 692:FreeRTOS/Source/queue.c **** 							{
 693:FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 694:FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 695:FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 696:FreeRTOS/Source/queue.c **** 							}
 697:FreeRTOS/Source/queue.c **** 						}
 698:FreeRTOS/Source/queue.c **** 						#endif
 699:FreeRTOS/Source/queue.c **** 
 700:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 701:FreeRTOS/Source/queue.c **** 						{
 702:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 703:FreeRTOS/Source/queue.c **** 							{
 704:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 705:FreeRTOS/Source/queue.c **** 							}
 706:FreeRTOS/Source/queue.c **** 						}
 707:FreeRTOS/Source/queue.c **** 					}
 708:FreeRTOS/Source/queue.c **** 					else
 709:FreeRTOS/Source/queue.c **** 					{
 710:FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 711:FreeRTOS/Source/queue.c **** 
 712:FreeRTOS/Source/queue.c **** 						/* We are not removing the data, so reset our read
 713:FreeRTOS/Source/queue.c **** 						pointer. */
 714:FreeRTOS/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 715:FreeRTOS/Source/queue.c **** 
 716:FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 717:FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 718:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 719:FreeRTOS/Source/queue.c **** 						{
 720:FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 721:FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 722:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 723:FreeRTOS/Source/queue.c **** 							{
 724:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 725:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 726:FreeRTOS/Source/queue.c **** 							}
 727:FreeRTOS/Source/queue.c **** 						}
 728:FreeRTOS/Source/queue.c **** 
 729:FreeRTOS/Source/queue.c **** 					}
 730:FreeRTOS/Source/queue.c **** 
 731:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 732:FreeRTOS/Source/queue.c **** 					return pdPASS;
 733:FreeRTOS/Source/queue.c **** 				}
 734:FreeRTOS/Source/queue.c **** 				else
 735:FreeRTOS/Source/queue.c **** 				{
 736:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 737:FreeRTOS/Source/queue.c **** 					{
 738:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 739:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 740:FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 741:FreeRTOS/Source/queue.c **** 					}
 742:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 743:FreeRTOS/Source/queue.c **** 					{
 744:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 745:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 746:FreeRTOS/Source/queue.c **** 					}
 747:FreeRTOS/Source/queue.c **** 				}
 748:FreeRTOS/Source/queue.c **** 			}
 749:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 750:FreeRTOS/Source/queue.c **** 
 751:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 752:FreeRTOS/Source/queue.c **** 			{
 753:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 754:FreeRTOS/Source/queue.c **** 				{
 755:FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 756:FreeRTOS/Source/queue.c **** 					{
 757:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 758:FreeRTOS/Source/queue.c **** 
 759:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 760:FreeRTOS/Source/queue.c **** 						{
 761:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 762:FreeRTOS/Source/queue.c **** 							{
 763:FreeRTOS/Source/queue.c **** 								portENTER_CRITICAL();
 764:FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 765:FreeRTOS/Source/queue.c **** 								portEXIT_CRITICAL();
 766:FreeRTOS/Source/queue.c **** 							}
 767:FreeRTOS/Source/queue.c **** 						}
 768:FreeRTOS/Source/queue.c **** 						#endif
 769:FreeRTOS/Source/queue.c **** 
 770:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 771:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 772:FreeRTOS/Source/queue.c **** 					}
 773:FreeRTOS/Source/queue.c **** 				}
 774:FreeRTOS/Source/queue.c **** 				else
 775:FreeRTOS/Source/queue.c **** 				{
 776:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 777:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 778:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 779:FreeRTOS/Source/queue.c **** 				}
 780:FreeRTOS/Source/queue.c **** 			}
 781:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 782:FreeRTOS/Source/queue.c **** 		}
 783:FreeRTOS/Source/queue.c **** 	}
 784:FreeRTOS/Source/queue.c **** 
 785:FreeRTOS/Source/queue.c **** 
 786:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 787:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 788:FreeRTOS/Source/queue.c **** 
 789:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 790:FreeRTOS/Source/queue.c **** {
 434              		.loc 1 790 0
 435              		.cfi_startproc
 436              		@ args = 0, pretend = 0, frame = 24
 437              		@ frame_needed = 1, uses_anonymous_args = 0
 438 0000 80B5     		push	{r7, lr}
 439              	.LCFI9:
 440              		.cfi_def_cfa_offset 8
 441              		.cfi_offset 14, -4
 442              		.cfi_offset 7, -8
 443 0002 86B0     		sub	sp, sp, #24
 444              	.LCFI10:
 445              		.cfi_def_cfa_offset 32
 446 0004 00AF     		add	r7, sp, #0
 447              	.LCFI11:
 448              		.cfi_def_cfa_register 7
 449 0006 F860     		str	r0, [r7, #12]
 450 0008 B960     		str	r1, [r7, #8]
 451 000a 7A60     		str	r2, [r7, #4]
 452 000c 3B60     		str	r3, [r7, #0]
 791:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 792:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 793:FreeRTOS/Source/queue.c **** 
 794:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 795:FreeRTOS/Source/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 796:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 797:FreeRTOS/Source/queue.c **** 
 798:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 799:FreeRTOS/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 800:FreeRTOS/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 801:FreeRTOS/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 802:FreeRTOS/Source/queue.c **** 	by this	post). */
 803:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 453              		.loc 1 803 0
 454 000e 4FF00003 		mov	r3, #0
 455 0012 3B61     		str	r3, [r7, #16]
 456              	@ 803 "FreeRTOS/Source/queue.c" 1
 457 0014 4FF0BF00 			mov r0, #191								
 458 0018 80F31188 		msr basepri, r0							
 459              	
 460              	@ 0 "" 2
 804:FreeRTOS/Source/queue.c **** 	{
 805:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 461              		.loc 1 805 0
 462              		.thumb
 463 001c FB68     		ldr	r3, [r7, #12]
 464 001e 9A6B     		ldr	r2, [r3, #56]
 465 0020 FB68     		ldr	r3, [r7, #12]
 466 0022 DB6B     		ldr	r3, [r3, #60]
 467 0024 9A42     		cmp	r2, r3
 468 0026 25D2     		bcs	.L20
 806:FreeRTOS/Source/queue.c **** 		{
 807:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 808:FreeRTOS/Source/queue.c **** 
 809:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 469              		.loc 1 809 0
 470 0028 F868     		ldr	r0, [r7, #12]
 471 002a B968     		ldr	r1, [r7, #8]
 472 002c 3A68     		ldr	r2, [r7, #0]
 473 002e FFF7FEFF 		bl	prvCopyDataToQueue
 810:FreeRTOS/Source/queue.c **** 
 811:FreeRTOS/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 812:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 813:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 474              		.loc 1 813 0
 475 0032 FB68     		ldr	r3, [r7, #12]
 476 0034 9B6C     		ldr	r3, [r3, #72]
 477 0036 B3F1FF3F 		cmp	r3, #-1
 478 003a 11D1     		bne	.L21
 814:FreeRTOS/Source/queue.c **** 			{
 815:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 479              		.loc 1 815 0
 480 003c FB68     		ldr	r3, [r7, #12]
 481 003e 5B6A     		ldr	r3, [r3, #36]
 482 0040 002B     		cmp	r3, #0
 483 0042 13D0     		beq	.L22
 816:FreeRTOS/Source/queue.c **** 				{
 817:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 484              		.loc 1 817 0
 485 0044 FB68     		ldr	r3, [r7, #12]
 486 0046 03F12403 		add	r3, r3, #36
 487 004a 1846     		mov	r0, r3
 488 004c FFF7FEFF 		bl	xTaskRemoveFromEventList
 489 0050 0346     		mov	r3, r0
 490 0052 002B     		cmp	r3, #0
 491 0054 0AD0     		beq	.L22
 818:FreeRTOS/Source/queue.c **** 					{
 819:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 820:FreeRTOS/Source/queue.c **** 						context	switch is required. */
 821:FreeRTOS/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 492              		.loc 1 821 0
 493 0056 7B68     		ldr	r3, [r7, #4]
 494 0058 4FF00102 		mov	r2, #1
 495 005c 1A60     		str	r2, [r3, #0]
 496 005e 05E0     		b	.L22
 497              	.L21:
 822:FreeRTOS/Source/queue.c **** 					}
 823:FreeRTOS/Source/queue.c **** 				}
 824:FreeRTOS/Source/queue.c **** 			}
 825:FreeRTOS/Source/queue.c **** 			else
 826:FreeRTOS/Source/queue.c **** 			{
 827:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 828:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
 829:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 498              		.loc 1 829 0
 499 0060 FB68     		ldr	r3, [r7, #12]
 500 0062 9B6C     		ldr	r3, [r3, #72]
 501 0064 03F10102 		add	r2, r3, #1
 502 0068 FB68     		ldr	r3, [r7, #12]
 503 006a 9A64     		str	r2, [r3, #72]
 504              	.L22:
 830:FreeRTOS/Source/queue.c **** 			}
 831:FreeRTOS/Source/queue.c **** 
 832:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 505              		.loc 1 832 0
 506 006c 4FF00103 		mov	r3, #1
 507 0070 7B61     		str	r3, [r7, #20]
 508 0072 02E0     		b	.L23
 509              	.L20:
 833:FreeRTOS/Source/queue.c **** 		}
 834:FreeRTOS/Source/queue.c **** 		else
 835:FreeRTOS/Source/queue.c **** 		{
 836:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 837:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 510              		.loc 1 837 0
 511 0074 4FF00003 		mov	r3, #0
 512 0078 7B61     		str	r3, [r7, #20]
 513              	.L23:
 838:FreeRTOS/Source/queue.c **** 		}
 839:FreeRTOS/Source/queue.c **** 	}
 840:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 514              		.loc 1 840 0
 515              	@ 840 "FreeRTOS/Source/queue.c" 1
 516 007a 4FF00000 			mov r0, #0					
 517 007e 80F31188 		msr basepri, r0				
 518              	
 519              	@ 0 "" 2
 841:FreeRTOS/Source/queue.c **** 
 842:FreeRTOS/Source/queue.c **** 	return xReturn;
 520              		.loc 1 842 0
 521              		.thumb
 522 0082 7B69     		ldr	r3, [r7, #20]
 843:FreeRTOS/Source/queue.c **** }
 523              		.loc 1 843 0
 524 0084 1846     		mov	r0, r3
 525 0086 07F11807 		add	r7, r7, #24
 526 008a BD46     		mov	sp, r7
 527 008c 80BD     		pop	{r7, pc}
 528              		.cfi_endproc
 529              	.LFE113:
 531 008e 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 532              		.align	2
 533              		.global	xQueueGenericReceive
 534              		.thumb
 535              		.thumb_func
 537              	xQueueGenericReceive:
 538              	.LFB114:
 844:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 845:FreeRTOS/Source/queue.c **** 
 846:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 847:FreeRTOS/Source/queue.c **** {
 539              		.loc 1 847 0
 540              		.cfi_startproc
 541              		@ args = 0, pretend = 0, frame = 32
 542              		@ frame_needed = 1, uses_anonymous_args = 0
 543 0000 80B5     		push	{r7, lr}
 544              	.LCFI12:
 545              		.cfi_def_cfa_offset 8
 546              		.cfi_offset 14, -4
 547              		.cfi_offset 7, -8
 548 0002 88B0     		sub	sp, sp, #32
 549              	.LCFI13:
 550              		.cfi_def_cfa_offset 40
 551 0004 00AF     		add	r7, sp, #0
 552              	.LCFI14:
 553              		.cfi_def_cfa_register 7
 554 0006 F860     		str	r0, [r7, #12]
 555 0008 B960     		str	r1, [r7, #8]
 556 000a 7A60     		str	r2, [r7, #4]
 557 000c 3B60     		str	r3, [r7, #0]
 848:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 558              		.loc 1 848 0
 559 000e 4FF00003 		mov	r3, #0
 560 0012 FB61     		str	r3, [r7, #28]
 561 0014 00E0     		b	.L38
 562              	.L39:
 849:FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 850:FreeRTOS/Source/queue.c **** signed char *pcOriginalReadPosition;
 851:FreeRTOS/Source/queue.c **** 
 852:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 853:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 854:FreeRTOS/Source/queue.c **** 
 855:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 856:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 857:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 858:FreeRTOS/Source/queue.c **** 
 859:FreeRTOS/Source/queue.c **** 	for( ;; )
 860:FreeRTOS/Source/queue.c **** 	{
 861:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 862:FreeRTOS/Source/queue.c **** 		{
 863:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 864:FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 865:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 866:FreeRTOS/Source/queue.c **** 			{
 867:FreeRTOS/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 868:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 869:FreeRTOS/Source/queue.c **** 
 870:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 871:FreeRTOS/Source/queue.c **** 
 872:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 873:FreeRTOS/Source/queue.c **** 				{
 874:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 875:FreeRTOS/Source/queue.c **** 
 876:FreeRTOS/Source/queue.c **** 					/* We are actually removing data. */
 877:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 878:FreeRTOS/Source/queue.c **** 
 879:FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 880:FreeRTOS/Source/queue.c **** 					{
 881:FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 882:FreeRTOS/Source/queue.c **** 						{
 883:FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
 884:FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
 885:FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 886:FreeRTOS/Source/queue.c **** 						}
 887:FreeRTOS/Source/queue.c **** 					}
 888:FreeRTOS/Source/queue.c **** 					#endif
 889:FreeRTOS/Source/queue.c **** 
 890:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 891:FreeRTOS/Source/queue.c **** 					{
 892:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 893:FreeRTOS/Source/queue.c **** 						{
 894:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 895:FreeRTOS/Source/queue.c **** 						}
 896:FreeRTOS/Source/queue.c **** 					}
 897:FreeRTOS/Source/queue.c **** 				}
 898:FreeRTOS/Source/queue.c **** 				else
 899:FreeRTOS/Source/queue.c **** 				{
 900:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 901:FreeRTOS/Source/queue.c **** 
 902:FreeRTOS/Source/queue.c **** 					/* We are not removing the data, so reset our read
 903:FreeRTOS/Source/queue.c **** 					pointer. */
 904:FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 905:FreeRTOS/Source/queue.c **** 
 906:FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 907:FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
 908:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 909:FreeRTOS/Source/queue.c **** 					{
 910:FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 911:FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 912:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 913:FreeRTOS/Source/queue.c **** 						{
 914:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 915:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:FreeRTOS/Source/queue.c **** 						}
 917:FreeRTOS/Source/queue.c **** 					}
 918:FreeRTOS/Source/queue.c **** 
 919:FreeRTOS/Source/queue.c **** 				}
 920:FreeRTOS/Source/queue.c **** 
 921:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 922:FreeRTOS/Source/queue.c **** 				return pdPASS;
 923:FreeRTOS/Source/queue.c **** 			}
 924:FreeRTOS/Source/queue.c **** 			else
 925:FreeRTOS/Source/queue.c **** 			{
 926:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 927:FreeRTOS/Source/queue.c **** 				{
 928:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 929:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 930:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 931:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 932:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 933:FreeRTOS/Source/queue.c **** 				}
 934:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 935:FreeRTOS/Source/queue.c **** 				{
 936:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 937:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 938:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 939:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 940:FreeRTOS/Source/queue.c **** 				}
 941:FreeRTOS/Source/queue.c **** 			}
 942:FreeRTOS/Source/queue.c **** 		}
 943:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 944:FreeRTOS/Source/queue.c **** 
 945:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 946:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 947:FreeRTOS/Source/queue.c **** 
 948:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 950:FreeRTOS/Source/queue.c **** 
 951:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 952:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 953:FreeRTOS/Source/queue.c **** 		{
 954:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 955:FreeRTOS/Source/queue.c **** 			{
 956:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 957:FreeRTOS/Source/queue.c **** 
 958:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 959:FreeRTOS/Source/queue.c **** 				{
 960:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 961:FreeRTOS/Source/queue.c **** 					{
 962:FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 963:FreeRTOS/Source/queue.c **** 						{
 964:FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 965:FreeRTOS/Source/queue.c **** 						}
 966:FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 967:FreeRTOS/Source/queue.c **** 					}
 968:FreeRTOS/Source/queue.c **** 				}
 969:FreeRTOS/Source/queue.c **** 				#endif
 970:FreeRTOS/Source/queue.c **** 
 971:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 972:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 973:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 974:FreeRTOS/Source/queue.c **** 				{
 975:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 976:FreeRTOS/Source/queue.c **** 				}
 977:FreeRTOS/Source/queue.c **** 			}
 978:FreeRTOS/Source/queue.c **** 			else
 979:FreeRTOS/Source/queue.c **** 			{
 980:FreeRTOS/Source/queue.c **** 				/* Try again. */
 981:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 982:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 983:FreeRTOS/Source/queue.c **** 			}
 984:FreeRTOS/Source/queue.c **** 		}
 985:FreeRTOS/Source/queue.c **** 		else
 986:FreeRTOS/Source/queue.c **** 		{
 987:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 988:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 989:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 990:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 991:FreeRTOS/Source/queue.c **** 		}
 992:FreeRTOS/Source/queue.c **** 	}
 563              		.loc 1 992 0
 564 0016 00BF     		nop
 565              	.L38:
 861:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 566              		.loc 1 861 0
 567 0018 FFF7FEFF 		bl	vPortEnterCritical
 865:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 568              		.loc 1 865 0
 569 001c FB68     		ldr	r3, [r7, #12]
 570 001e 9B6B     		ldr	r3, [r3, #56]
 571 0020 002B     		cmp	r3, #0
 572 0022 3FD0     		beq	.L25
 868:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 573              		.loc 1 868 0
 574 0024 FB68     		ldr	r3, [r7, #12]
 575 0026 DB68     		ldr	r3, [r3, #12]
 576 0028 BB61     		str	r3, [r7, #24]
 870:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 577              		.loc 1 870 0
 578 002a F868     		ldr	r0, [r7, #12]
 579 002c B968     		ldr	r1, [r7, #8]
 580 002e FFF7FEFF 		bl	prvCopyDataFromQueue
 872:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 581              		.loc 1 872 0
 582 0032 3B68     		ldr	r3, [r7, #0]
 583 0034 002B     		cmp	r3, #0
 584 0036 1ED1     		bne	.L26
 877:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 585              		.loc 1 877 0
 586 0038 FB68     		ldr	r3, [r7, #12]
 587 003a 9B6B     		ldr	r3, [r3, #56]
 588 003c 03F1FF32 		add	r2, r3, #-1
 589 0040 FB68     		ldr	r3, [r7, #12]
 590 0042 9A63     		str	r2, [r3, #56]
 881:FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 591              		.loc 1 881 0
 592 0044 FB68     		ldr	r3, [r7, #12]
 593 0046 1B68     		ldr	r3, [r3, #0]
 594 0048 002B     		cmp	r3, #0
 595 004a 04D1     		bne	.L27
 885:FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 596              		.loc 1 885 0
 597 004c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 598 0050 0246     		mov	r2, r0
 599 0052 FB68     		ldr	r3, [r7, #12]
 600 0054 5A60     		str	r2, [r3, #4]
 601              	.L27:
 890:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 602              		.loc 1 890 0
 603 0056 FB68     		ldr	r3, [r7, #12]
 604 0058 1B69     		ldr	r3, [r3, #16]
 605 005a 002B     		cmp	r3, #0
 606 005c 1DD0     		beq	.L28
 892:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 607              		.loc 1 892 0
 608 005e FB68     		ldr	r3, [r7, #12]
 609 0060 03F11003 		add	r3, r3, #16
 610 0064 1846     		mov	r0, r3
 611 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 612 006a 0346     		mov	r3, r0
 613 006c 012B     		cmp	r3, #1
 614 006e 14D1     		bne	.L28
 894:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 615              		.loc 1 894 0
 616 0070 FFF7FEFF 		bl	vPortYieldFromISR
 617 0074 11E0     		b	.L28
 618              	.L26:
 904:FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 619              		.loc 1 904 0
 620 0076 FB68     		ldr	r3, [r7, #12]
 621 0078 BA69     		ldr	r2, [r7, #24]
 622 007a DA60     		str	r2, [r3, #12]
 908:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 623              		.loc 1 908 0
 624 007c FB68     		ldr	r3, [r7, #12]
 625 007e 5B6A     		ldr	r3, [r3, #36]
 626 0080 002B     		cmp	r3, #0
 627 0082 0AD0     		beq	.L28
 912:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 628              		.loc 1 912 0
 629 0084 FB68     		ldr	r3, [r7, #12]
 630 0086 03F12403 		add	r3, r3, #36
 631 008a 1846     		mov	r0, r3
 632 008c FFF7FEFF 		bl	xTaskRemoveFromEventList
 633 0090 0346     		mov	r3, r0
 634 0092 002B     		cmp	r3, #0
 635 0094 01D0     		beq	.L28
 915:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 636              		.loc 1 915 0
 637 0096 FFF7FEFF 		bl	vPortYieldFromISR
 638              	.L28:
 921:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 639              		.loc 1 921 0
 640 009a FFF7FEFF 		bl	vPortExitCritical
 922:FreeRTOS/Source/queue.c **** 				return pdPASS;
 641              		.loc 1 922 0
 642 009e 4FF00103 		mov	r3, #1
 643 00a2 6BE0     		b	.L29
 644              	.L25:
 926:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 645              		.loc 1 926 0
 646 00a4 7B68     		ldr	r3, [r7, #4]
 647 00a6 002B     		cmp	r3, #0
 648 00a8 04D1     		bne	.L30
 930:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 649              		.loc 1 930 0
 650 00aa FFF7FEFF 		bl	vPortExitCritical
 932:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 651              		.loc 1 932 0
 652 00ae 4FF00003 		mov	r3, #0
 653 00b2 63E0     		b	.L29
 654              	.L30:
 934:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 655              		.loc 1 934 0
 656 00b4 FB69     		ldr	r3, [r7, #28]
 657 00b6 002B     		cmp	r3, #0
 658 00b8 07D1     		bne	.L31
 938:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 659              		.loc 1 938 0
 660 00ba 07F11003 		add	r3, r7, #16
 661 00be 1846     		mov	r0, r3
 662 00c0 FFF7FEFF 		bl	vTaskSetTimeOutState
 939:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 663              		.loc 1 939 0
 664 00c4 4FF00103 		mov	r3, #1
 665 00c8 FB61     		str	r3, [r7, #28]
 666              	.L31:
 943:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 667              		.loc 1 943 0
 668 00ca FFF7FEFF 		bl	vPortExitCritical
 948:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 669              		.loc 1 948 0
 670 00ce FFF7FEFF 		bl	vTaskSuspendAll
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 671              		.loc 1 949 0
 672 00d2 FFF7FEFF 		bl	vPortEnterCritical
 673 00d6 FB68     		ldr	r3, [r7, #12]
 674 00d8 5B6C     		ldr	r3, [r3, #68]
 675 00da B3F1FF3F 		cmp	r3, #-1
 676 00de 03D1     		bne	.L32
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 677              		.loc 1 949 0 is_stmt 0 discriminator 1
 678 00e0 FB68     		ldr	r3, [r7, #12]
 679 00e2 4FF00002 		mov	r2, #0
 680 00e6 5A64     		str	r2, [r3, #68]
 681              	.L32:
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 682              		.loc 1 949 0 discriminator 2
 683 00e8 FB68     		ldr	r3, [r7, #12]
 684 00ea 9B6C     		ldr	r3, [r3, #72]
 685 00ec B3F1FF3F 		cmp	r3, #-1
 686 00f0 03D1     		bne	.L33
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 687              		.loc 1 949 0 discriminator 3
 688 00f2 FB68     		ldr	r3, [r7, #12]
 689 00f4 4FF00002 		mov	r2, #0
 690 00f8 9A64     		str	r2, [r3, #72]
 691              	.L33:
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 692              		.loc 1 949 0 discriminator 4
 693 00fa FFF7FEFF 		bl	vPortExitCritical
 952:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 694              		.loc 1 952 0 is_stmt 1 discriminator 4
 695 00fe 07F11003 		add	r3, r7, #16
 696 0102 1846     		mov	r0, r3
 697 0104 07F10403 		add	r3, r7, #4
 698 0108 1946     		mov	r1, r3
 699 010a FFF7FEFF 		bl	xTaskCheckForTimeOut
 700 010e 0346     		mov	r3, r0
 701 0110 002B     		cmp	r3, #0
 702 0112 2CD1     		bne	.L34
 954:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 703              		.loc 1 954 0
 704 0114 F868     		ldr	r0, [r7, #12]
 705 0116 FFF7FEFF 		bl	prvIsQueueEmpty
 706 011a 0346     		mov	r3, r0
 707 011c 002B     		cmp	r3, #0
 708 011e 20D0     		beq	.L35
 960:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 709              		.loc 1 960 0
 710 0120 FB68     		ldr	r3, [r7, #12]
 711 0122 1B68     		ldr	r3, [r3, #0]
 712 0124 002B     		cmp	r3, #0
 713 0126 08D1     		bne	.L36
 962:FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 714              		.loc 1 962 0
 715 0128 FFF7FEFF 		bl	vPortEnterCritical
 964:FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 716              		.loc 1 964 0
 717 012c FB68     		ldr	r3, [r7, #12]
 718 012e 5B68     		ldr	r3, [r3, #4]
 719 0130 1846     		mov	r0, r3
 720 0132 FFF7FEFF 		bl	vTaskPriorityInherit
 966:FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 721              		.loc 1 966 0
 722 0136 FFF7FEFF 		bl	vPortExitCritical
 723              	.L36:
 971:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 724              		.loc 1 971 0
 725 013a FB68     		ldr	r3, [r7, #12]
 726 013c 03F12402 		add	r2, r3, #36
 727 0140 7B68     		ldr	r3, [r7, #4]
 728 0142 1046     		mov	r0, r2
 729 0144 1946     		mov	r1, r3
 730 0146 FFF7FEFF 		bl	vTaskPlaceOnEventList
 972:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 731              		.loc 1 972 0
 732 014a F868     		ldr	r0, [r7, #12]
 733 014c FFF7FEFF 		bl	prvUnlockQueue
 973:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 734              		.loc 1 973 0
 735 0150 FFF7FEFF 		bl	xTaskResumeAll
 736 0154 0346     		mov	r3, r0
 737 0156 002B     		cmp	r3, #0
 738 0158 7FF45DAF 		bne	.L39
 975:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 739              		.loc 1 975 0
 740 015c FFF7FEFF 		bl	vPortYieldFromISR
 741              		.loc 1 992 0
 742 0160 59E7     		b	.L39
 743              	.L35:
 981:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 744              		.loc 1 981 0
 745 0162 F868     		ldr	r0, [r7, #12]
 746 0164 FFF7FEFF 		bl	prvUnlockQueue
 982:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 747              		.loc 1 982 0
 748 0168 FFF7FEFF 		bl	xTaskResumeAll
 749              		.loc 1 992 0
 750 016c 53E7     		b	.L39
 751              	.L34:
 987:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 752              		.loc 1 987 0
 753 016e F868     		ldr	r0, [r7, #12]
 754 0170 FFF7FEFF 		bl	prvUnlockQueue
 988:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 755              		.loc 1 988 0
 756 0174 FFF7FEFF 		bl	xTaskResumeAll
 990:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 757              		.loc 1 990 0
 758 0178 4FF00003 		mov	r3, #0
 759              	.L29:
 993:FreeRTOS/Source/queue.c **** }
 760              		.loc 1 993 0
 761 017c 1846     		mov	r0, r3
 762 017e 07F12007 		add	r7, r7, #32
 763 0182 BD46     		mov	sp, r7
 764 0184 80BD     		pop	{r7, pc}
 765              		.cfi_endproc
 766              	.LFE114:
 768 0186 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 769              		.align	2
 770              		.global	xQueueReceiveFromISR
 771              		.thumb
 772              		.thumb_func
 774              	xQueueReceiveFromISR:
 775              	.LFB115:
 994:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 995:FreeRTOS/Source/queue.c **** 
 996:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 997:FreeRTOS/Source/queue.c **** {
 776              		.loc 1 997 0
 777              		.cfi_startproc
 778              		@ args = 0, pretend = 0, frame = 24
 779              		@ frame_needed = 1, uses_anonymous_args = 0
 780 0000 80B5     		push	{r7, lr}
 781              	.LCFI15:
 782              		.cfi_def_cfa_offset 8
 783              		.cfi_offset 14, -4
 784              		.cfi_offset 7, -8
 785 0002 86B0     		sub	sp, sp, #24
 786              	.LCFI16:
 787              		.cfi_def_cfa_offset 32
 788 0004 00AF     		add	r7, sp, #0
 789              	.LCFI17:
 790              		.cfi_def_cfa_register 7
 791 0006 F860     		str	r0, [r7, #12]
 792 0008 B960     		str	r1, [r7, #8]
 793 000a 7A60     		str	r2, [r7, #4]
 998:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 999:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1000:FreeRTOS/Source/queue.c **** 
1001:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1002:FreeRTOS/Source/queue.c **** 	configASSERT( pxTaskWoken );
1003:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1004:FreeRTOS/Source/queue.c **** 
1005:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 794              		.loc 1 1005 0
 795 000c 4FF00003 		mov	r3, #0
 796 0010 3B61     		str	r3, [r7, #16]
 797              	@ 1005 "FreeRTOS/Source/queue.c" 1
 798 0012 4FF0BF00 			mov r0, #191								
 799 0016 80F31188 		msr basepri, r0							
 800              	
 801              	@ 0 "" 2
1006:FreeRTOS/Source/queue.c **** 	{
1007:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1008:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 802              		.loc 1 1008 0
 803              		.thumb
 804 001a FB68     		ldr	r3, [r7, #12]
 805 001c 9B6B     		ldr	r3, [r3, #56]
 806 001e 002B     		cmp	r3, #0
 807 0020 2AD0     		beq	.L41
1009:FreeRTOS/Source/queue.c **** 		{
1010:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1011:FreeRTOS/Source/queue.c **** 
1012:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 808              		.loc 1 1012 0
 809 0022 F868     		ldr	r0, [r7, #12]
 810 0024 B968     		ldr	r1, [r7, #8]
 811 0026 FFF7FEFF 		bl	prvCopyDataFromQueue
1013:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 812              		.loc 1 1013 0
 813 002a FB68     		ldr	r3, [r7, #12]
 814 002c 9B6B     		ldr	r3, [r3, #56]
 815 002e 03F1FF32 		add	r2, r3, #-1
 816 0032 FB68     		ldr	r3, [r7, #12]
 817 0034 9A63     		str	r2, [r3, #56]
1014:FreeRTOS/Source/queue.c **** 
1015:FreeRTOS/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1016:FreeRTOS/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1017:FreeRTOS/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1018:FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 818              		.loc 1 1018 0
 819 0036 FB68     		ldr	r3, [r7, #12]
 820 0038 5B6C     		ldr	r3, [r3, #68]
 821 003a B3F1FF3F 		cmp	r3, #-1
 822 003e 11D1     		bne	.L42
1019:FreeRTOS/Source/queue.c **** 			{
1020:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 823              		.loc 1 1020 0
 824 0040 FB68     		ldr	r3, [r7, #12]
 825 0042 1B69     		ldr	r3, [r3, #16]
 826 0044 002B     		cmp	r3, #0
 827 0046 13D0     		beq	.L43
1021:FreeRTOS/Source/queue.c **** 				{
1022:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 828              		.loc 1 1022 0
 829 0048 FB68     		ldr	r3, [r7, #12]
 830 004a 03F11003 		add	r3, r3, #16
 831 004e 1846     		mov	r0, r3
 832 0050 FFF7FEFF 		bl	xTaskRemoveFromEventList
 833 0054 0346     		mov	r3, r0
 834 0056 002B     		cmp	r3, #0
 835 0058 0AD0     		beq	.L43
1023:FreeRTOS/Source/queue.c **** 					{
1024:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1025:FreeRTOS/Source/queue.c **** 						force a context switch. */
1026:FreeRTOS/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 836              		.loc 1 1026 0
 837 005a 7B68     		ldr	r3, [r7, #4]
 838 005c 4FF00102 		mov	r2, #1
 839 0060 1A60     		str	r2, [r3, #0]
 840 0062 05E0     		b	.L43
 841              	.L42:
1027:FreeRTOS/Source/queue.c **** 					}
1028:FreeRTOS/Source/queue.c **** 				}
1029:FreeRTOS/Source/queue.c **** 			}
1030:FreeRTOS/Source/queue.c **** 			else
1031:FreeRTOS/Source/queue.c **** 			{
1032:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1033:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1034:FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
 842              		.loc 1 1034 0
 843 0064 FB68     		ldr	r3, [r7, #12]
 844 0066 5B6C     		ldr	r3, [r3, #68]
 845 0068 03F10102 		add	r2, r3, #1
 846 006c FB68     		ldr	r3, [r7, #12]
 847 006e 5A64     		str	r2, [r3, #68]
 848              	.L43:
1035:FreeRTOS/Source/queue.c **** 			}
1036:FreeRTOS/Source/queue.c **** 
1037:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 849              		.loc 1 1037 0
 850 0070 4FF00103 		mov	r3, #1
 851 0074 7B61     		str	r3, [r7, #20]
 852 0076 02E0     		b	.L44
 853              	.L41:
1038:FreeRTOS/Source/queue.c **** 		}
1039:FreeRTOS/Source/queue.c **** 		else
1040:FreeRTOS/Source/queue.c **** 		{
1041:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 854              		.loc 1 1041 0
 855 0078 4FF00003 		mov	r3, #0
 856 007c 7B61     		str	r3, [r7, #20]
 857              	.L44:
1042:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1043:FreeRTOS/Source/queue.c **** 		}
1044:FreeRTOS/Source/queue.c **** 	}
1045:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 858              		.loc 1 1045 0
 859              	@ 1045 "FreeRTOS/Source/queue.c" 1
 860 007e 4FF00000 			mov r0, #0					
 861 0082 80F31188 		msr basepri, r0				
 862              	
 863              	@ 0 "" 2
1046:FreeRTOS/Source/queue.c **** 
1047:FreeRTOS/Source/queue.c **** 	return xReturn;
 864              		.loc 1 1047 0
 865              		.thumb
 866 0086 7B69     		ldr	r3, [r7, #20]
1048:FreeRTOS/Source/queue.c **** }
 867              		.loc 1 1048 0
 868 0088 1846     		mov	r0, r3
 869 008a 07F11807 		add	r7, r7, #24
 870 008e BD46     		mov	sp, r7
 871 0090 80BD     		pop	{r7, pc}
 872              		.cfi_endproc
 873              	.LFE115:
 875 0092 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 876              		.align	2
 877              		.global	uxQueueMessagesWaiting
 878              		.thumb
 879              		.thumb_func
 881              	uxQueueMessagesWaiting:
 882              	.LFB116:
1049:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1050:FreeRTOS/Source/queue.c **** 
1051:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1052:FreeRTOS/Source/queue.c **** {
 883              		.loc 1 1052 0
 884              		.cfi_startproc
 885              		@ args = 0, pretend = 0, frame = 16
 886              		@ frame_needed = 1, uses_anonymous_args = 0
 887 0000 80B5     		push	{r7, lr}
 888              	.LCFI18:
 889              		.cfi_def_cfa_offset 8
 890              		.cfi_offset 14, -4
 891              		.cfi_offset 7, -8
 892 0002 84B0     		sub	sp, sp, #16
 893              	.LCFI19:
 894              		.cfi_def_cfa_offset 24
 895 0004 00AF     		add	r7, sp, #0
 896              	.LCFI20:
 897              		.cfi_def_cfa_register 7
 898 0006 7860     		str	r0, [r7, #4]
1053:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1054:FreeRTOS/Source/queue.c **** 
1055:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1056:FreeRTOS/Source/queue.c **** 
1057:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 899              		.loc 1 1057 0
 900 0008 FFF7FEFF 		bl	vPortEnterCritical
1058:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 901              		.loc 1 1058 0
 902 000c 7B68     		ldr	r3, [r7, #4]
 903 000e 9B6B     		ldr	r3, [r3, #56]
 904 0010 FB60     		str	r3, [r7, #12]
1059:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 905              		.loc 1 1059 0
 906 0012 FFF7FEFF 		bl	vPortExitCritical
1060:FreeRTOS/Source/queue.c **** 
1061:FreeRTOS/Source/queue.c **** 	return uxReturn;
 907              		.loc 1 1061 0
 908 0016 FB68     		ldr	r3, [r7, #12]
1062:FreeRTOS/Source/queue.c **** }
 909              		.loc 1 1062 0
 910 0018 1846     		mov	r0, r3
 911 001a 07F11007 		add	r7, r7, #16
 912 001e BD46     		mov	sp, r7
 913 0020 80BD     		pop	{r7, pc}
 914              		.cfi_endproc
 915              	.LFE116:
 917 0022 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 918              		.align	2
 919              		.global	uxQueueMessagesWaitingFromISR
 920              		.thumb
 921              		.thumb_func
 923              	uxQueueMessagesWaitingFromISR:
 924              	.LFB117:
1063:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1064:FreeRTOS/Source/queue.c **** 
1065:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1066:FreeRTOS/Source/queue.c **** {
 925              		.loc 1 1066 0
 926              		.cfi_startproc
 927              		@ args = 0, pretend = 0, frame = 16
 928              		@ frame_needed = 1, uses_anonymous_args = 0
 929              		@ link register save eliminated.
 930 0000 80B4     		push	{r7}
 931              	.LCFI21:
 932              		.cfi_def_cfa_offset 4
 933              		.cfi_offset 7, -4
 934 0002 85B0     		sub	sp, sp, #20
 935              	.LCFI22:
 936              		.cfi_def_cfa_offset 24
 937 0004 00AF     		add	r7, sp, #0
 938              	.LCFI23:
 939              		.cfi_def_cfa_register 7
 940 0006 7860     		str	r0, [r7, #4]
1067:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1068:FreeRTOS/Source/queue.c **** 
1069:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1070:FreeRTOS/Source/queue.c **** 
1071:FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 941              		.loc 1 1071 0
 942 0008 7B68     		ldr	r3, [r7, #4]
 943 000a 9B6B     		ldr	r3, [r3, #56]
 944 000c FB60     		str	r3, [r7, #12]
1072:FreeRTOS/Source/queue.c **** 
1073:FreeRTOS/Source/queue.c **** 	return uxReturn;
 945              		.loc 1 1073 0
 946 000e FB68     		ldr	r3, [r7, #12]
1074:FreeRTOS/Source/queue.c **** }
 947              		.loc 1 1074 0
 948 0010 1846     		mov	r0, r3
 949 0012 07F11407 		add	r7, r7, #20
 950 0016 BD46     		mov	sp, r7
 951 0018 80BC     		pop	{r7}
 952 001a 7047     		bx	lr
 953              		.cfi_endproc
 954              	.LFE117:
 956              		.section	.text.vQueueDelete,"ax",%progbits
 957              		.align	2
 958              		.global	vQueueDelete
 959              		.thumb
 960              		.thumb_func
 962              	vQueueDelete:
 963              	.LFB118:
1075:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1076:FreeRTOS/Source/queue.c **** 
1077:FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1078:FreeRTOS/Source/queue.c **** {
 964              		.loc 1 1078 0
 965              		.cfi_startproc
 966              		@ args = 0, pretend = 0, frame = 8
 967              		@ frame_needed = 1, uses_anonymous_args = 0
 968 0000 80B5     		push	{r7, lr}
 969              	.LCFI24:
 970              		.cfi_def_cfa_offset 8
 971              		.cfi_offset 14, -4
 972              		.cfi_offset 7, -8
 973 0002 82B0     		sub	sp, sp, #8
 974              	.LCFI25:
 975              		.cfi_def_cfa_offset 16
 976 0004 00AF     		add	r7, sp, #0
 977              	.LCFI26:
 978              		.cfi_def_cfa_register 7
 979 0006 7860     		str	r0, [r7, #4]
1079:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1080:FreeRTOS/Source/queue.c **** 
1081:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1082:FreeRTOS/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1083:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 980              		.loc 1 1083 0
 981 0008 7B68     		ldr	r3, [r7, #4]
 982 000a 1B68     		ldr	r3, [r3, #0]
 983 000c 1846     		mov	r0, r3
 984 000e FFF7FEFF 		bl	free
1084:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
 985              		.loc 1 1084 0
 986 0012 7868     		ldr	r0, [r7, #4]
 987 0014 FFF7FEFF 		bl	free
1085:FreeRTOS/Source/queue.c **** }
 988              		.loc 1 1085 0
 989 0018 07F10807 		add	r7, r7, #8
 990 001c BD46     		mov	sp, r7
 991 001e 80BD     		pop	{r7, pc}
 992              		.cfi_endproc
 993              	.LFE118:
 995              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 996              		.align	2
 997              		.thumb
 998              		.thumb_func
 1000              	prvCopyDataToQueue:
 1001              	.LFB119:
1086:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1087:FreeRTOS/Source/queue.c **** 
1088:FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1089:FreeRTOS/Source/queue.c **** {
 1002              		.loc 1 1089 0
 1003              		.cfi_startproc
 1004              		@ args = 0, pretend = 0, frame = 16
 1005              		@ frame_needed = 1, uses_anonymous_args = 0
 1006 0000 80B5     		push	{r7, lr}
 1007              	.LCFI27:
 1008              		.cfi_def_cfa_offset 8
 1009              		.cfi_offset 14, -4
 1010              		.cfi_offset 7, -8
 1011 0002 84B0     		sub	sp, sp, #16
 1012              	.LCFI28:
 1013              		.cfi_def_cfa_offset 24
 1014 0004 00AF     		add	r7, sp, #0
 1015              	.LCFI29:
 1016              		.cfi_def_cfa_register 7
 1017 0006 F860     		str	r0, [r7, #12]
 1018 0008 B960     		str	r1, [r7, #8]
 1019 000a 7A60     		str	r2, [r7, #4]
1090:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1020              		.loc 1 1090 0
 1021 000c FB68     		ldr	r3, [r7, #12]
 1022 000e 1B6C     		ldr	r3, [r3, #64]
 1023 0010 002B     		cmp	r3, #0
 1024 0012 0DD1     		bne	.L49
1091:FreeRTOS/Source/queue.c **** 	{
1092:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1093:FreeRTOS/Source/queue.c **** 		{
1094:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1025              		.loc 1 1094 0
 1026 0014 FB68     		ldr	r3, [r7, #12]
 1027 0016 1B68     		ldr	r3, [r3, #0]
 1028 0018 002B     		cmp	r3, #0
 1029 001a 4AD1     		bne	.L50
1095:FreeRTOS/Source/queue.c **** 			{
1096:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1097:FreeRTOS/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1030              		.loc 1 1097 0
 1031 001c FB68     		ldr	r3, [r7, #12]
 1032 001e 5B68     		ldr	r3, [r3, #4]
 1033 0020 1846     		mov	r0, r3
 1034 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1098:FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1035              		.loc 1 1098 0
 1036 0026 FB68     		ldr	r3, [r7, #12]
 1037 0028 4FF00002 		mov	r2, #0
 1038 002c 5A60     		str	r2, [r3, #4]
 1039 002e 40E0     		b	.L50
 1040              	.L49:
1099:FreeRTOS/Source/queue.c **** 			}
1100:FreeRTOS/Source/queue.c **** 		}
1101:FreeRTOS/Source/queue.c **** 		#endif
1102:FreeRTOS/Source/queue.c **** 	}
1103:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1041              		.loc 1 1103 0
 1042 0030 7B68     		ldr	r3, [r7, #4]
 1043 0032 002B     		cmp	r3, #0
 1044 0034 1BD1     		bne	.L51
1104:FreeRTOS/Source/queue.c **** 	{
1105:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1045              		.loc 1 1105 0
 1046 0036 FB68     		ldr	r3, [r7, #12]
 1047 0038 9968     		ldr	r1, [r3, #8]
 1048 003a FB68     		ldr	r3, [r7, #12]
 1049 003c 1B6C     		ldr	r3, [r3, #64]
 1050 003e BA68     		ldr	r2, [r7, #8]
 1051 0040 0846     		mov	r0, r1
 1052 0042 1146     		mov	r1, r2
 1053 0044 1A46     		mov	r2, r3
 1054 0046 FFF7FEFF 		bl	memcpy
1106:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1055              		.loc 1 1106 0
 1056 004a FB68     		ldr	r3, [r7, #12]
 1057 004c 9A68     		ldr	r2, [r3, #8]
 1058 004e FB68     		ldr	r3, [r7, #12]
 1059 0050 1B6C     		ldr	r3, [r3, #64]
 1060 0052 D218     		adds	r2, r2, r3
 1061 0054 FB68     		ldr	r3, [r7, #12]
 1062 0056 9A60     		str	r2, [r3, #8]
1107:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1063              		.loc 1 1107 0
 1064 0058 FB68     		ldr	r3, [r7, #12]
 1065 005a 9A68     		ldr	r2, [r3, #8]
 1066 005c FB68     		ldr	r3, [r7, #12]
 1067 005e 5B68     		ldr	r3, [r3, #4]
 1068 0060 9A42     		cmp	r2, r3
 1069 0062 26D3     		bcc	.L50
1108:FreeRTOS/Source/queue.c **** 		{
1109:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1070              		.loc 1 1109 0
 1071 0064 FB68     		ldr	r3, [r7, #12]
 1072 0066 1A68     		ldr	r2, [r3, #0]
 1073 0068 FB68     		ldr	r3, [r7, #12]
 1074 006a 9A60     		str	r2, [r3, #8]
 1075 006c 21E0     		b	.L50
 1076              	.L51:
1110:FreeRTOS/Source/queue.c **** 		}
1111:FreeRTOS/Source/queue.c **** 	}
1112:FreeRTOS/Source/queue.c **** 	else
1113:FreeRTOS/Source/queue.c **** 	{
1114:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1077              		.loc 1 1114 0
 1078 006e FB68     		ldr	r3, [r7, #12]
 1079 0070 D968     		ldr	r1, [r3, #12]
 1080 0072 FB68     		ldr	r3, [r7, #12]
 1081 0074 1B6C     		ldr	r3, [r3, #64]
 1082 0076 BA68     		ldr	r2, [r7, #8]
 1083 0078 0846     		mov	r0, r1
 1084 007a 1146     		mov	r1, r2
 1085 007c 1A46     		mov	r2, r3
 1086 007e FFF7FEFF 		bl	memcpy
1115:FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1087              		.loc 1 1115 0
 1088 0082 FB68     		ldr	r3, [r7, #12]
 1089 0084 DA68     		ldr	r2, [r3, #12]
 1090 0086 FB68     		ldr	r3, [r7, #12]
 1091 0088 1B6C     		ldr	r3, [r3, #64]
 1092 008a C3F10003 		rsb	r3, r3, #0
 1093 008e D218     		adds	r2, r2, r3
 1094 0090 FB68     		ldr	r3, [r7, #12]
 1095 0092 DA60     		str	r2, [r3, #12]
1116:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1096              		.loc 1 1116 0
 1097 0094 FB68     		ldr	r3, [r7, #12]
 1098 0096 DA68     		ldr	r2, [r3, #12]
 1099 0098 FB68     		ldr	r3, [r7, #12]
 1100 009a 1B68     		ldr	r3, [r3, #0]
 1101 009c 9A42     		cmp	r2, r3
 1102 009e 08D2     		bcs	.L50
1117:FreeRTOS/Source/queue.c **** 		{
1118:FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1103              		.loc 1 1118 0
 1104 00a0 FB68     		ldr	r3, [r7, #12]
 1105 00a2 5A68     		ldr	r2, [r3, #4]
 1106 00a4 FB68     		ldr	r3, [r7, #12]
 1107 00a6 1B6C     		ldr	r3, [r3, #64]
 1108 00a8 C3F10003 		rsb	r3, r3, #0
 1109 00ac D218     		adds	r2, r2, r3
 1110 00ae FB68     		ldr	r3, [r7, #12]
 1111 00b0 DA60     		str	r2, [r3, #12]
 1112              	.L50:
1119:FreeRTOS/Source/queue.c **** 		}
1120:FreeRTOS/Source/queue.c **** 	}
1121:FreeRTOS/Source/queue.c **** 
1122:FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1113              		.loc 1 1122 0
 1114 00b2 FB68     		ldr	r3, [r7, #12]
 1115 00b4 9B6B     		ldr	r3, [r3, #56]
 1116 00b6 03F10102 		add	r2, r3, #1
 1117 00ba FB68     		ldr	r3, [r7, #12]
 1118 00bc 9A63     		str	r2, [r3, #56]
1123:FreeRTOS/Source/queue.c **** }
 1119              		.loc 1 1123 0
 1120 00be 07F11007 		add	r7, r7, #16
 1121 00c2 BD46     		mov	sp, r7
 1122 00c4 80BD     		pop	{r7, pc}
 1123              		.cfi_endproc
 1124              	.LFE119:
 1126 00c6 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1127              		.align	2
 1128              		.thumb
 1129              		.thumb_func
 1131              	prvCopyDataFromQueue:
 1132              	.LFB120:
1124:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1125:FreeRTOS/Source/queue.c **** 
1126:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1127:FreeRTOS/Source/queue.c **** {
 1133              		.loc 1 1127 0
 1134              		.cfi_startproc
 1135              		@ args = 0, pretend = 0, frame = 8
 1136              		@ frame_needed = 1, uses_anonymous_args = 0
 1137 0000 80B5     		push	{r7, lr}
 1138              	.LCFI30:
 1139              		.cfi_def_cfa_offset 8
 1140              		.cfi_offset 14, -4
 1141              		.cfi_offset 7, -8
 1142 0002 82B0     		sub	sp, sp, #8
 1143              	.LCFI31:
 1144              		.cfi_def_cfa_offset 16
 1145 0004 00AF     		add	r7, sp, #0
 1146              	.LCFI32:
 1147              		.cfi_def_cfa_register 7
 1148 0006 7860     		str	r0, [r7, #4]
 1149 0008 3960     		str	r1, [r7, #0]
1128:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1150              		.loc 1 1128 0
 1151 000a 7B68     		ldr	r3, [r7, #4]
 1152 000c 1B68     		ldr	r3, [r3, #0]
 1153 000e 002B     		cmp	r3, #0
 1154 0010 1AD0     		beq	.L52
1129:FreeRTOS/Source/queue.c **** 	{
1130:FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1155              		.loc 1 1130 0
 1156 0012 7B68     		ldr	r3, [r7, #4]
 1157 0014 DA68     		ldr	r2, [r3, #12]
 1158 0016 7B68     		ldr	r3, [r7, #4]
 1159 0018 1B6C     		ldr	r3, [r3, #64]
 1160 001a D218     		adds	r2, r2, r3
 1161 001c 7B68     		ldr	r3, [r7, #4]
 1162 001e DA60     		str	r2, [r3, #12]
1131:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1163              		.loc 1 1131 0
 1164 0020 7B68     		ldr	r3, [r7, #4]
 1165 0022 DA68     		ldr	r2, [r3, #12]
 1166 0024 7B68     		ldr	r3, [r7, #4]
 1167 0026 5B68     		ldr	r3, [r3, #4]
 1168 0028 9A42     		cmp	r2, r3
 1169 002a 03D3     		bcc	.L54
1132:FreeRTOS/Source/queue.c **** 		{
1133:FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1170              		.loc 1 1133 0
 1171 002c 7B68     		ldr	r3, [r7, #4]
 1172 002e 1A68     		ldr	r2, [r3, #0]
 1173 0030 7B68     		ldr	r3, [r7, #4]
 1174 0032 DA60     		str	r2, [r3, #12]
 1175              	.L54:
1134:FreeRTOS/Source/queue.c **** 		}
1135:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1176              		.loc 1 1135 0
 1177 0034 7B68     		ldr	r3, [r7, #4]
 1178 0036 DA68     		ldr	r2, [r3, #12]
 1179 0038 7B68     		ldr	r3, [r7, #4]
 1180 003a 1B6C     		ldr	r3, [r3, #64]
 1181 003c 3968     		ldr	r1, [r7, #0]
 1182 003e 0846     		mov	r0, r1
 1183 0040 1146     		mov	r1, r2
 1184 0042 1A46     		mov	r2, r3
 1185 0044 FFF7FEFF 		bl	memcpy
 1186              	.L52:
1136:FreeRTOS/Source/queue.c **** 	}
1137:FreeRTOS/Source/queue.c **** }
 1187              		.loc 1 1137 0
 1188 0048 07F10807 		add	r7, r7, #8
 1189 004c BD46     		mov	sp, r7
 1190 004e 80BD     		pop	{r7, pc}
 1191              		.cfi_endproc
 1192              	.LFE120:
 1194              		.section	.text.prvUnlockQueue,"ax",%progbits
 1195              		.align	2
 1196              		.thumb
 1197              		.thumb_func
 1199              	prvUnlockQueue:
 1200              	.LFB121:
1138:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1139:FreeRTOS/Source/queue.c **** 
1140:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1141:FreeRTOS/Source/queue.c **** {
 1201              		.loc 1 1141 0
 1202              		.cfi_startproc
 1203              		@ args = 0, pretend = 0, frame = 8
 1204              		@ frame_needed = 1, uses_anonymous_args = 0
 1205 0000 80B5     		push	{r7, lr}
 1206              	.LCFI33:
 1207              		.cfi_def_cfa_offset 8
 1208              		.cfi_offset 14, -4
 1209              		.cfi_offset 7, -8
 1210 0002 82B0     		sub	sp, sp, #8
 1211              	.LCFI34:
 1212              		.cfi_def_cfa_offset 16
 1213 0004 00AF     		add	r7, sp, #0
 1214              	.LCFI35:
 1215              		.cfi_def_cfa_register 7
 1216 0006 7860     		str	r0, [r7, #4]
1142:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1143:FreeRTOS/Source/queue.c **** 
1144:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1145:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1146:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1147:FreeRTOS/Source/queue.c **** 	updated. */
1148:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1217              		.loc 1 1148 0
 1218 0008 FFF7FEFF 		bl	vPortEnterCritical
1149:FreeRTOS/Source/queue.c **** 	{
1150:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1151:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1219              		.loc 1 1151 0
 1220 000c 14E0     		b	.L56
 1221              	.L60:
1152:FreeRTOS/Source/queue.c **** 		{
1153:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1154:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1155:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1222              		.loc 1 1155 0
 1223 000e 7B68     		ldr	r3, [r7, #4]
 1224 0010 5B6A     		ldr	r3, [r3, #36]
 1225 0012 002B     		cmp	r3, #0
 1226 0014 15D0     		beq	.L66
1156:FreeRTOS/Source/queue.c **** 			{
1157:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1158:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1159:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1227              		.loc 1 1159 0
 1228 0016 7B68     		ldr	r3, [r7, #4]
 1229 0018 03F12403 		add	r3, r3, #36
 1230 001c 1846     		mov	r0, r3
 1231 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1232 0022 0346     		mov	r3, r0
 1233 0024 002B     		cmp	r3, #0
 1234 0026 01D0     		beq	.L58
1160:FreeRTOS/Source/queue.c **** 				{
1161:FreeRTOS/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1162:FreeRTOS/Source/queue.c **** 					context	switch is required. */
1163:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1235              		.loc 1 1163 0
 1236 0028 FFF7FEFF 		bl	vTaskMissedYield
 1237              	.L58:
1164:FreeRTOS/Source/queue.c **** 				}
1165:FreeRTOS/Source/queue.c **** 
1166:FreeRTOS/Source/queue.c **** 				--( pxQueue->xTxLock );
 1238              		.loc 1 1166 0
 1239 002c 7B68     		ldr	r3, [r7, #4]
 1240 002e 9B6C     		ldr	r3, [r3, #72]
 1241 0030 03F1FF32 		add	r2, r3, #-1
 1242 0034 7B68     		ldr	r3, [r7, #4]
 1243 0036 9A64     		str	r2, [r3, #72]
 1244              	.L56:
1151:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1245              		.loc 1 1151 0 discriminator 1
 1246 0038 7B68     		ldr	r3, [r7, #4]
 1247 003a 9B6C     		ldr	r3, [r3, #72]
 1248 003c 002B     		cmp	r3, #0
 1249 003e E6DC     		bgt	.L60
 1250 0040 00E0     		b	.L59
 1251              	.L66:
1167:FreeRTOS/Source/queue.c **** 			}
1168:FreeRTOS/Source/queue.c **** 			else
1169:FreeRTOS/Source/queue.c **** 			{
1170:FreeRTOS/Source/queue.c **** 				break;
 1252              		.loc 1 1170 0
 1253 0042 00BF     		nop
 1254              	.L59:
1171:FreeRTOS/Source/queue.c **** 			}
1172:FreeRTOS/Source/queue.c **** 		}
1173:FreeRTOS/Source/queue.c **** 
1174:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1255              		.loc 1 1174 0
 1256 0044 7B68     		ldr	r3, [r7, #4]
 1257 0046 4FF0FF32 		mov	r2, #-1
 1258 004a 9A64     		str	r2, [r3, #72]
1175:FreeRTOS/Source/queue.c **** 	}
1176:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1259              		.loc 1 1176 0
 1260 004c FFF7FEFF 		bl	vPortExitCritical
1177:FreeRTOS/Source/queue.c **** 
1178:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1179:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1261              		.loc 1 1179 0
 1262 0050 FFF7FEFF 		bl	vPortEnterCritical
1180:FreeRTOS/Source/queue.c **** 	{
1181:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1263              		.loc 1 1181 0
 1264 0054 14E0     		b	.L61
 1265              	.L65:
1182:FreeRTOS/Source/queue.c **** 		{
1183:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1266              		.loc 1 1183 0
 1267 0056 7B68     		ldr	r3, [r7, #4]
 1268 0058 1B69     		ldr	r3, [r3, #16]
 1269 005a 002B     		cmp	r3, #0
 1270 005c 15D0     		beq	.L67
1184:FreeRTOS/Source/queue.c **** 			{
1185:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1271              		.loc 1 1185 0
 1272 005e 7B68     		ldr	r3, [r7, #4]
 1273 0060 03F11003 		add	r3, r3, #16
 1274 0064 1846     		mov	r0, r3
 1275 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1276 006a 0346     		mov	r3, r0
 1277 006c 002B     		cmp	r3, #0
 1278 006e 01D0     		beq	.L63
1186:FreeRTOS/Source/queue.c **** 				{
1187:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1279              		.loc 1 1187 0
 1280 0070 FFF7FEFF 		bl	vTaskMissedYield
 1281              	.L63:
1188:FreeRTOS/Source/queue.c **** 				}
1189:FreeRTOS/Source/queue.c **** 
1190:FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 1282              		.loc 1 1190 0
 1283 0074 7B68     		ldr	r3, [r7, #4]
 1284 0076 5B6C     		ldr	r3, [r3, #68]
 1285 0078 03F1FF32 		add	r2, r3, #-1
 1286 007c 7B68     		ldr	r3, [r7, #4]
 1287 007e 5A64     		str	r2, [r3, #68]
 1288              	.L61:
1181:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1289              		.loc 1 1181 0 discriminator 1
 1290 0080 7B68     		ldr	r3, [r7, #4]
 1291 0082 5B6C     		ldr	r3, [r3, #68]
 1292 0084 002B     		cmp	r3, #0
 1293 0086 E6DC     		bgt	.L65
 1294 0088 00E0     		b	.L64
 1295              	.L67:
1191:FreeRTOS/Source/queue.c **** 			}
1192:FreeRTOS/Source/queue.c **** 			else
1193:FreeRTOS/Source/queue.c **** 			{
1194:FreeRTOS/Source/queue.c **** 				break;
 1296              		.loc 1 1194 0
 1297 008a 00BF     		nop
 1298              	.L64:
1195:FreeRTOS/Source/queue.c **** 			}
1196:FreeRTOS/Source/queue.c **** 		}
1197:FreeRTOS/Source/queue.c **** 
1198:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1299              		.loc 1 1198 0
 1300 008c 7B68     		ldr	r3, [r7, #4]
 1301 008e 4FF0FF32 		mov	r2, #-1
 1302 0092 5A64     		str	r2, [r3, #68]
1199:FreeRTOS/Source/queue.c **** 	}
1200:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1303              		.loc 1 1200 0
 1304 0094 FFF7FEFF 		bl	vPortExitCritical
1201:FreeRTOS/Source/queue.c **** }
 1305              		.loc 1 1201 0
 1306 0098 07F10807 		add	r7, r7, #8
 1307 009c BD46     		mov	sp, r7
 1308 009e 80BD     		pop	{r7, pc}
 1309              		.cfi_endproc
 1310              	.LFE121:
 1312              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1313              		.align	2
 1314              		.thumb
 1315              		.thumb_func
 1317              	prvIsQueueEmpty:
 1318              	.LFB122:
1202:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1203:FreeRTOS/Source/queue.c **** 
1204:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1205:FreeRTOS/Source/queue.c **** {
 1319              		.loc 1 1205 0
 1320              		.cfi_startproc
 1321              		@ args = 0, pretend = 0, frame = 16
 1322              		@ frame_needed = 1, uses_anonymous_args = 0
 1323 0000 80B5     		push	{r7, lr}
 1324              	.LCFI36:
 1325              		.cfi_def_cfa_offset 8
 1326              		.cfi_offset 14, -4
 1327              		.cfi_offset 7, -8
 1328 0002 84B0     		sub	sp, sp, #16
 1329              	.LCFI37:
 1330              		.cfi_def_cfa_offset 24
 1331 0004 00AF     		add	r7, sp, #0
 1332              	.LCFI38:
 1333              		.cfi_def_cfa_register 7
 1334 0006 7860     		str	r0, [r7, #4]
1206:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1207:FreeRTOS/Source/queue.c **** 
1208:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1335              		.loc 1 1208 0
 1336 0008 FFF7FEFF 		bl	vPortEnterCritical
1209:FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1337              		.loc 1 1209 0
 1338 000c 7B68     		ldr	r3, [r7, #4]
 1339 000e 9B6B     		ldr	r3, [r3, #56]
 1340 0010 002B     		cmp	r3, #0
 1341 0012 14BF     		ite	ne
 1342 0014 0023     		movne	r3, #0
 1343 0016 0123     		moveq	r3, #1
 1344 0018 FB60     		str	r3, [r7, #12]
1210:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1345              		.loc 1 1210 0
 1346 001a FFF7FEFF 		bl	vPortExitCritical
1211:FreeRTOS/Source/queue.c **** 
1212:FreeRTOS/Source/queue.c **** 	return xReturn;
 1347              		.loc 1 1212 0
 1348 001e FB68     		ldr	r3, [r7, #12]
1213:FreeRTOS/Source/queue.c **** }
 1349              		.loc 1 1213 0
 1350 0020 1846     		mov	r0, r3
 1351 0022 07F11007 		add	r7, r7, #16
 1352 0026 BD46     		mov	sp, r7
 1353 0028 80BD     		pop	{r7, pc}
 1354              		.cfi_endproc
 1355              	.LFE122:
 1357 002a 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1358              		.align	2
 1359              		.global	xQueueIsQueueEmptyFromISR
 1360              		.thumb
 1361              		.thumb_func
 1363              	xQueueIsQueueEmptyFromISR:
 1364              	.LFB123:
1214:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1215:FreeRTOS/Source/queue.c **** 
1216:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1217:FreeRTOS/Source/queue.c **** {
 1365              		.loc 1 1217 0
 1366              		.cfi_startproc
 1367              		@ args = 0, pretend = 0, frame = 16
 1368              		@ frame_needed = 1, uses_anonymous_args = 0
 1369              		@ link register save eliminated.
 1370 0000 80B4     		push	{r7}
 1371              	.LCFI39:
 1372              		.cfi_def_cfa_offset 4
 1373              		.cfi_offset 7, -4
 1374 0002 85B0     		sub	sp, sp, #20
 1375              	.LCFI40:
 1376              		.cfi_def_cfa_offset 24
 1377 0004 00AF     		add	r7, sp, #0
 1378              	.LCFI41:
 1379              		.cfi_def_cfa_register 7
 1380 0006 7860     		str	r0, [r7, #4]
1218:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1219:FreeRTOS/Source/queue.c **** 
1220:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1221:FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1381              		.loc 1 1221 0
 1382 0008 7B68     		ldr	r3, [r7, #4]
 1383 000a 9B6B     		ldr	r3, [r3, #56]
 1384 000c 002B     		cmp	r3, #0
 1385 000e 14BF     		ite	ne
 1386 0010 0023     		movne	r3, #0
 1387 0012 0123     		moveq	r3, #1
 1388 0014 FB60     		str	r3, [r7, #12]
1222:FreeRTOS/Source/queue.c **** 
1223:FreeRTOS/Source/queue.c **** 	return xReturn;
 1389              		.loc 1 1223 0
 1390 0016 FB68     		ldr	r3, [r7, #12]
1224:FreeRTOS/Source/queue.c **** }
 1391              		.loc 1 1224 0
 1392 0018 1846     		mov	r0, r3
 1393 001a 07F11407 		add	r7, r7, #20
 1394 001e BD46     		mov	sp, r7
 1395 0020 80BC     		pop	{r7}
 1396 0022 7047     		bx	lr
 1397              		.cfi_endproc
 1398              	.LFE123:
 1400              		.section	.text.prvIsQueueFull,"ax",%progbits
 1401              		.align	2
 1402              		.thumb
 1403              		.thumb_func
 1405              	prvIsQueueFull:
 1406              	.LFB124:
1225:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1226:FreeRTOS/Source/queue.c **** 
1227:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1228:FreeRTOS/Source/queue.c **** {
 1407              		.loc 1 1228 0
 1408              		.cfi_startproc
 1409              		@ args = 0, pretend = 0, frame = 16
 1410              		@ frame_needed = 1, uses_anonymous_args = 0
 1411 0000 80B5     		push	{r7, lr}
 1412              	.LCFI42:
 1413              		.cfi_def_cfa_offset 8
 1414              		.cfi_offset 14, -4
 1415              		.cfi_offset 7, -8
 1416 0002 84B0     		sub	sp, sp, #16
 1417              	.LCFI43:
 1418              		.cfi_def_cfa_offset 24
 1419 0004 00AF     		add	r7, sp, #0
 1420              	.LCFI44:
 1421              		.cfi_def_cfa_register 7
 1422 0006 7860     		str	r0, [r7, #4]
1229:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:FreeRTOS/Source/queue.c **** 
1231:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1423              		.loc 1 1231 0
 1424 0008 FFF7FEFF 		bl	vPortEnterCritical
1232:FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1425              		.loc 1 1232 0
 1426 000c 7B68     		ldr	r3, [r7, #4]
 1427 000e 9A6B     		ldr	r2, [r3, #56]
 1428 0010 7B68     		ldr	r3, [r7, #4]
 1429 0012 DB6B     		ldr	r3, [r3, #60]
 1430 0014 9A42     		cmp	r2, r3
 1431 0016 14BF     		ite	ne
 1432 0018 0023     		movne	r3, #0
 1433 001a 0123     		moveq	r3, #1
 1434 001c FB60     		str	r3, [r7, #12]
1233:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1435              		.loc 1 1233 0
 1436 001e FFF7FEFF 		bl	vPortExitCritical
1234:FreeRTOS/Source/queue.c **** 
1235:FreeRTOS/Source/queue.c **** 	return xReturn;
 1437              		.loc 1 1235 0
 1438 0022 FB68     		ldr	r3, [r7, #12]
1236:FreeRTOS/Source/queue.c **** }
 1439              		.loc 1 1236 0
 1440 0024 1846     		mov	r0, r3
 1441 0026 07F11007 		add	r7, r7, #16
 1442 002a BD46     		mov	sp, r7
 1443 002c 80BD     		pop	{r7, pc}
 1444              		.cfi_endproc
 1445              	.LFE124:
 1447 002e 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1448              		.align	2
 1449              		.global	xQueueIsQueueFullFromISR
 1450              		.thumb
 1451              		.thumb_func
 1453              	xQueueIsQueueFullFromISR:
 1454              	.LFB125:
1237:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1238:FreeRTOS/Source/queue.c **** 
1239:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1240:FreeRTOS/Source/queue.c **** {
 1455              		.loc 1 1240 0
 1456              		.cfi_startproc
 1457              		@ args = 0, pretend = 0, frame = 16
 1458              		@ frame_needed = 1, uses_anonymous_args = 0
 1459              		@ link register save eliminated.
 1460 0000 80B4     		push	{r7}
 1461              	.LCFI45:
 1462              		.cfi_def_cfa_offset 4
 1463              		.cfi_offset 7, -4
 1464 0002 85B0     		sub	sp, sp, #20
 1465              	.LCFI46:
 1466              		.cfi_def_cfa_offset 24
 1467 0004 00AF     		add	r7, sp, #0
 1468              	.LCFI47:
 1469              		.cfi_def_cfa_register 7
 1470 0006 7860     		str	r0, [r7, #4]
1241:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1242:FreeRTOS/Source/queue.c **** 
1243:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1244:FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1471              		.loc 1 1244 0
 1472 0008 7B68     		ldr	r3, [r7, #4]
 1473 000a 9A6B     		ldr	r2, [r3, #56]
 1474 000c 7B68     		ldr	r3, [r7, #4]
 1475 000e DB6B     		ldr	r3, [r3, #60]
 1476 0010 9A42     		cmp	r2, r3
 1477 0012 14BF     		ite	ne
 1478 0014 0023     		movne	r3, #0
 1479 0016 0123     		moveq	r3, #1
 1480 0018 FB60     		str	r3, [r7, #12]
1245:FreeRTOS/Source/queue.c **** 
1246:FreeRTOS/Source/queue.c **** 	return xReturn;
 1481              		.loc 1 1246 0
 1482 001a FB68     		ldr	r3, [r7, #12]
1247:FreeRTOS/Source/queue.c **** }
 1483              		.loc 1 1247 0
 1484 001c 1846     		mov	r0, r3
 1485 001e 07F11407 		add	r7, r7, #20
 1486 0022 BD46     		mov	sp, r7
 1487 0024 80BC     		pop	{r7}
 1488 0026 7047     		bx	lr
 1489              		.cfi_endproc
 1490              	.LFE125:
 1492              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 1493              		.align	2
 1494              		.global	vQueueWaitForMessageRestricted
 1495              		.thumb
 1496              		.thumb_func
 1498              	vQueueWaitForMessageRestricted:
 1499              	.LFB126:
1248:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1249:FreeRTOS/Source/queue.c **** 
1250:FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1251:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xT
1252:FreeRTOS/Source/queue.c **** {
1253:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1254:FreeRTOS/Source/queue.c **** 
1255:FreeRTOS/Source/queue.c **** 	/* If the queue is already full we may have to block.  A critical section
1256:FreeRTOS/Source/queue.c **** 	is required to prevent an interrupt removing something from the queue
1257:FreeRTOS/Source/queue.c **** 	between the check to see if the queue is full and blocking on the queue. */
1258:FreeRTOS/Source/queue.c **** 	portDISABLE_INTERRUPTS();
1259:FreeRTOS/Source/queue.c **** 	{
1260:FreeRTOS/Source/queue.c **** 		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1261:FreeRTOS/Source/queue.c **** 		{
1262:FreeRTOS/Source/queue.c **** 			/* The queue is full - do we want to block or just leave without
1263:FreeRTOS/Source/queue.c **** 			posting? */
1264:FreeRTOS/Source/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1265:FreeRTOS/Source/queue.c **** 			{
1266:FreeRTOS/Source/queue.c **** 				/* As this is called from a coroutine we cannot block directly, but
1267:FreeRTOS/Source/queue.c **** 				return indicating that we need to block. */
1268:FreeRTOS/Source/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1269:FreeRTOS/Source/queue.c **** 				portENABLE_INTERRUPTS();
1270:FreeRTOS/Source/queue.c **** 				return errQUEUE_BLOCKED;
1271:FreeRTOS/Source/queue.c **** 			}
1272:FreeRTOS/Source/queue.c **** 			else
1273:FreeRTOS/Source/queue.c **** 			{
1274:FreeRTOS/Source/queue.c **** 				portENABLE_INTERRUPTS();
1275:FreeRTOS/Source/queue.c **** 				return errQUEUE_FULL;
1276:FreeRTOS/Source/queue.c **** 			}
1277:FreeRTOS/Source/queue.c **** 		}
1278:FreeRTOS/Source/queue.c **** 	}
1279:FreeRTOS/Source/queue.c **** 	portENABLE_INTERRUPTS();
1280:FreeRTOS/Source/queue.c **** 
1281:FreeRTOS/Source/queue.c **** 	portNOP();
1282:FreeRTOS/Source/queue.c **** 
1283:FreeRTOS/Source/queue.c **** 	portDISABLE_INTERRUPTS();
1284:FreeRTOS/Source/queue.c **** 	{
1285:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1286:FreeRTOS/Source/queue.c **** 		{
1287:FreeRTOS/Source/queue.c **** 			/* There is room in the queue, copy the data into the queue. */
1288:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1289:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1290:FreeRTOS/Source/queue.c **** 
1291:FreeRTOS/Source/queue.c **** 			/* Were any co-routines waiting for data to become available? */
1292:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1293:FreeRTOS/Source/queue.c **** 			{
1294:FreeRTOS/Source/queue.c **** 				/* In this instance the co-routine could be placed directly
1295:FreeRTOS/Source/queue.c **** 				into the ready list as we are within a critical section.
1296:FreeRTOS/Source/queue.c **** 				Instead the same pending ready list mechanism is used as if
1297:FreeRTOS/Source/queue.c **** 				the event were caused from within an interrupt. */
1298:FreeRTOS/Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1299:FreeRTOS/Source/queue.c **** 				{
1300:FreeRTOS/Source/queue.c **** 					/* The co-routine waiting has a higher priority so record
1301:FreeRTOS/Source/queue.c **** 					that a yield might be appropriate. */
1302:FreeRTOS/Source/queue.c **** 					xReturn = errQUEUE_YIELD;
1303:FreeRTOS/Source/queue.c **** 				}
1304:FreeRTOS/Source/queue.c **** 			}
1305:FreeRTOS/Source/queue.c **** 		}
1306:FreeRTOS/Source/queue.c **** 		else
1307:FreeRTOS/Source/queue.c **** 		{
1308:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1309:FreeRTOS/Source/queue.c **** 		}
1310:FreeRTOS/Source/queue.c **** 	}
1311:FreeRTOS/Source/queue.c **** 	portENABLE_INTERRUPTS();
1312:FreeRTOS/Source/queue.c **** 
1313:FreeRTOS/Source/queue.c **** 	return xReturn;
1314:FreeRTOS/Source/queue.c **** }
1315:FreeRTOS/Source/queue.c **** #endif
1316:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1317:FreeRTOS/Source/queue.c **** 
1318:FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1319:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWa
1320:FreeRTOS/Source/queue.c **** {
1321:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1322:FreeRTOS/Source/queue.c **** 
1323:FreeRTOS/Source/queue.c **** 	/* If the queue is already empty we may have to block.  A critical section
1324:FreeRTOS/Source/queue.c **** 	is required to prevent an interrupt adding something to the queue
1325:FreeRTOS/Source/queue.c **** 	between the check to see if the queue is empty and blocking on the queue. */
1326:FreeRTOS/Source/queue.c **** 	portDISABLE_INTERRUPTS();
1327:FreeRTOS/Source/queue.c **** 	{
1328:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1329:FreeRTOS/Source/queue.c **** 		{
1330:FreeRTOS/Source/queue.c **** 			/* There are no messages in the queue, do we want to block or just
1331:FreeRTOS/Source/queue.c **** 			leave with nothing? */
1332:FreeRTOS/Source/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1333:FreeRTOS/Source/queue.c **** 			{
1334:FreeRTOS/Source/queue.c **** 				/* As this is a co-routine we cannot block directly, but return
1335:FreeRTOS/Source/queue.c **** 				indicating that we need to block. */
1336:FreeRTOS/Source/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1337:FreeRTOS/Source/queue.c **** 				portENABLE_INTERRUPTS();
1338:FreeRTOS/Source/queue.c **** 				return errQUEUE_BLOCKED;
1339:FreeRTOS/Source/queue.c **** 			}
1340:FreeRTOS/Source/queue.c **** 			else
1341:FreeRTOS/Source/queue.c **** 			{
1342:FreeRTOS/Source/queue.c **** 				portENABLE_INTERRUPTS();
1343:FreeRTOS/Source/queue.c **** 				return errQUEUE_FULL;
1344:FreeRTOS/Source/queue.c **** 			}
1345:FreeRTOS/Source/queue.c **** 		}
1346:FreeRTOS/Source/queue.c **** 	}
1347:FreeRTOS/Source/queue.c **** 	portENABLE_INTERRUPTS();
1348:FreeRTOS/Source/queue.c **** 
1349:FreeRTOS/Source/queue.c **** 	portNOP();
1350:FreeRTOS/Source/queue.c **** 
1351:FreeRTOS/Source/queue.c **** 	portDISABLE_INTERRUPTS();
1352:FreeRTOS/Source/queue.c **** 	{
1353:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1354:FreeRTOS/Source/queue.c **** 		{
1355:FreeRTOS/Source/queue.c **** 			/* Data is available from the queue. */
1356:FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1357:FreeRTOS/Source/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1358:FreeRTOS/Source/queue.c **** 			{
1359:FreeRTOS/Source/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1360:FreeRTOS/Source/queue.c **** 			}
1361:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1362:FreeRTOS/Source/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1363:FreeRTOS/Source/queue.c **** 
1364:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1365:FreeRTOS/Source/queue.c **** 
1366:FreeRTOS/Source/queue.c **** 			/* Were any co-routines waiting for space to become available? */
1367:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1368:FreeRTOS/Source/queue.c **** 			{
1369:FreeRTOS/Source/queue.c **** 				/* In this instance the co-routine could be placed directly
1370:FreeRTOS/Source/queue.c **** 				into the ready list as we are within a critical section.
1371:FreeRTOS/Source/queue.c **** 				Instead the same pending ready list mechanism is used as if
1372:FreeRTOS/Source/queue.c **** 				the event were caused from within an interrupt. */
1373:FreeRTOS/Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1374:FreeRTOS/Source/queue.c **** 				{
1375:FreeRTOS/Source/queue.c **** 					xReturn = errQUEUE_YIELD;
1376:FreeRTOS/Source/queue.c **** 				}
1377:FreeRTOS/Source/queue.c **** 			}
1378:FreeRTOS/Source/queue.c **** 		}
1379:FreeRTOS/Source/queue.c **** 		else
1380:FreeRTOS/Source/queue.c **** 		{
1381:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1382:FreeRTOS/Source/queue.c **** 		}
1383:FreeRTOS/Source/queue.c **** 	}
1384:FreeRTOS/Source/queue.c **** 	portENABLE_INTERRUPTS();
1385:FreeRTOS/Source/queue.c **** 
1386:FreeRTOS/Source/queue.c **** 	return xReturn;
1387:FreeRTOS/Source/queue.c **** }
1388:FreeRTOS/Source/queue.c **** #endif
1389:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1390:FreeRTOS/Source/queue.c **** 
1391:FreeRTOS/Source/queue.c **** 
1392:FreeRTOS/Source/queue.c **** 
1393:FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1394:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed p
1395:FreeRTOS/Source/queue.c **** {
1396:FreeRTOS/Source/queue.c **** 	/* Cannot block within an ISR so if there is no space on the queue then
1397:FreeRTOS/Source/queue.c **** 	exit without doing anything. */
1398:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1399:FreeRTOS/Source/queue.c **** 	{
1400:FreeRTOS/Source/queue.c **** 		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1401:FreeRTOS/Source/queue.c **** 
1402:FreeRTOS/Source/queue.c **** 		/* We only want to wake one co-routine per ISR, so check that a
1403:FreeRTOS/Source/queue.c **** 		co-routine has not already been woken. */
1404:FreeRTOS/Source/queue.c **** 		if( xCoRoutinePreviouslyWoken == pdFALSE )
1405:FreeRTOS/Source/queue.c **** 		{
1406:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1407:FreeRTOS/Source/queue.c **** 			{
1408:FreeRTOS/Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1409:FreeRTOS/Source/queue.c **** 				{
1410:FreeRTOS/Source/queue.c **** 					return pdTRUE;
1411:FreeRTOS/Source/queue.c **** 				}
1412:FreeRTOS/Source/queue.c **** 			}
1413:FreeRTOS/Source/queue.c **** 		}
1414:FreeRTOS/Source/queue.c **** 	}
1415:FreeRTOS/Source/queue.c **** 
1416:FreeRTOS/Source/queue.c **** 	return xCoRoutinePreviouslyWoken;
1417:FreeRTOS/Source/queue.c **** }
1418:FreeRTOS/Source/queue.c **** #endif
1419:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1420:FreeRTOS/Source/queue.c **** 
1421:FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1422:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_
1423:FreeRTOS/Source/queue.c **** {
1424:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1425:FreeRTOS/Source/queue.c **** 
1426:FreeRTOS/Source/queue.c **** 	/* We cannot block from an ISR, so check there is data available. If
1427:FreeRTOS/Source/queue.c **** 	not then just leave without doing anything. */
1428:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1429:FreeRTOS/Source/queue.c **** 	{
1430:FreeRTOS/Source/queue.c **** 		/* Copy the data from the queue. */
1431:FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1432:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1433:FreeRTOS/Source/queue.c **** 		{
1434:FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1435:FreeRTOS/Source/queue.c **** 		}
1436:FreeRTOS/Source/queue.c **** 		--( pxQueue->uxMessagesWaiting );
1437:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1438:FreeRTOS/Source/queue.c **** 
1439:FreeRTOS/Source/queue.c **** 		if( ( *pxCoRoutineWoken ) == pdFALSE )
1440:FreeRTOS/Source/queue.c **** 		{
1441:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1442:FreeRTOS/Source/queue.c **** 			{
1443:FreeRTOS/Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1444:FreeRTOS/Source/queue.c **** 				{
1445:FreeRTOS/Source/queue.c **** 					*pxCoRoutineWoken = pdTRUE;
1446:FreeRTOS/Source/queue.c **** 				}
1447:FreeRTOS/Source/queue.c **** 			}
1448:FreeRTOS/Source/queue.c **** 		}
1449:FreeRTOS/Source/queue.c **** 
1450:FreeRTOS/Source/queue.c **** 		xReturn = pdPASS;
1451:FreeRTOS/Source/queue.c **** 	}
1452:FreeRTOS/Source/queue.c **** 	else
1453:FreeRTOS/Source/queue.c **** 	{
1454:FreeRTOS/Source/queue.c **** 		xReturn = pdFAIL;
1455:FreeRTOS/Source/queue.c **** 	}
1456:FreeRTOS/Source/queue.c **** 
1457:FreeRTOS/Source/queue.c **** 	return xReturn;
1458:FreeRTOS/Source/queue.c **** }
1459:FreeRTOS/Source/queue.c **** #endif
1460:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1461:FreeRTOS/Source/queue.c **** 
1462:FreeRTOS/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1463:FreeRTOS/Source/queue.c **** 
1464:FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1465:FreeRTOS/Source/queue.c **** 	{
1466:FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE ux;
1467:FreeRTOS/Source/queue.c **** 
1468:FreeRTOS/Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1469:FreeRTOS/Source/queue.c **** 		a free slot. */
1470:FreeRTOS/Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
1471:FreeRTOS/Source/queue.c **** 		{
1472:FreeRTOS/Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
1473:FreeRTOS/Source/queue.c **** 			{
1474:FreeRTOS/Source/queue.c **** 				/* Store the information on this queue. */
1475:FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
1476:FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
1477:FreeRTOS/Source/queue.c **** 				break;
1478:FreeRTOS/Source/queue.c **** 			}
1479:FreeRTOS/Source/queue.c **** 		}
1480:FreeRTOS/Source/queue.c **** 	}
1481:FreeRTOS/Source/queue.c **** 
1482:FreeRTOS/Source/queue.c **** #endif
1483:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1484:FreeRTOS/Source/queue.c **** 
1485:FreeRTOS/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1486:FreeRTOS/Source/queue.c **** 
1487:FreeRTOS/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1488:FreeRTOS/Source/queue.c **** 	{
1489:FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE ux;
1490:FreeRTOS/Source/queue.c **** 
1491:FreeRTOS/Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1492:FreeRTOS/Source/queue.c **** 		registry. */
1493:FreeRTOS/Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
1494:FreeRTOS/Source/queue.c **** 		{
1495:FreeRTOS/Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
1496:FreeRTOS/Source/queue.c **** 			{
1497:FreeRTOS/Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1498:FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
1499:FreeRTOS/Source/queue.c **** 				break;
1500:FreeRTOS/Source/queue.c **** 			}
1501:FreeRTOS/Source/queue.c **** 		}
1502:FreeRTOS/Source/queue.c **** 
1503:FreeRTOS/Source/queue.c **** 	}
1504:FreeRTOS/Source/queue.c **** 
1505:FreeRTOS/Source/queue.c **** #endif
1506:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1507:FreeRTOS/Source/queue.c **** 
1508:FreeRTOS/Source/queue.c **** #if configUSE_TIMERS == 1
1509:FreeRTOS/Source/queue.c **** 
1510:FreeRTOS/Source/queue.c **** 	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
1511:FreeRTOS/Source/queue.c **** 	{
 1500              		.loc 1 1511 0
 1501              		.cfi_startproc
 1502              		@ args = 0, pretend = 0, frame = 8
 1503              		@ frame_needed = 1, uses_anonymous_args = 0
 1504 0000 80B5     		push	{r7, lr}
 1505              	.LCFI48:
 1506              		.cfi_def_cfa_offset 8
 1507              		.cfi_offset 14, -4
 1508              		.cfi_offset 7, -8
 1509 0002 82B0     		sub	sp, sp, #8
 1510              	.LCFI49:
 1511              		.cfi_def_cfa_offset 16
 1512 0004 00AF     		add	r7, sp, #0
 1513              	.LCFI50:
 1514              		.cfi_def_cfa_register 7
 1515 0006 7860     		str	r0, [r7, #4]
 1516 0008 3960     		str	r1, [r7, #0]
1512:FreeRTOS/Source/queue.c **** 		/* This function should not be called by application code hence the
1513:FreeRTOS/Source/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1514:FreeRTOS/Source/queue.c **** 		designed for use by kernel code, and has special calling requirements.
1515:FreeRTOS/Source/queue.c **** 		It can result in vListInsert() being called on a list that can only
1516:FreeRTOS/Source/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
1517:FreeRTOS/Source/queue.c **** 		so it should be called with the scheduler locked and not from a critical
1518:FreeRTOS/Source/queue.c **** 		section. */
1519:FreeRTOS/Source/queue.c **** 
1520:FreeRTOS/Source/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
1521:FreeRTOS/Source/queue.c **** 		will not actually cause the task to block, just place it on a blocked
1522:FreeRTOS/Source/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
1523:FreeRTOS/Source/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
1524:FreeRTOS/Source/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
1525:FreeRTOS/Source/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
1526:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1517              		.loc 1 1526 0
 1518 000a FFF7FEFF 		bl	vPortEnterCritical
 1519 000e 7B68     		ldr	r3, [r7, #4]
 1520 0010 5B6C     		ldr	r3, [r3, #68]
 1521 0012 B3F1FF3F 		cmp	r3, #-1
 1522 0016 03D1     		bne	.L73
 1523              		.loc 1 1526 0 is_stmt 0 discriminator 1
 1524 0018 7B68     		ldr	r3, [r7, #4]
 1525 001a 4FF00002 		mov	r2, #0
 1526 001e 5A64     		str	r2, [r3, #68]
 1527              	.L73:
 1528              		.loc 1 1526 0 discriminator 2
 1529 0020 7B68     		ldr	r3, [r7, #4]
 1530 0022 9B6C     		ldr	r3, [r3, #72]
 1531 0024 B3F1FF3F 		cmp	r3, #-1
 1532 0028 03D1     		bne	.L74
 1533              		.loc 1 1526 0 discriminator 3
 1534 002a 7B68     		ldr	r3, [r7, #4]
 1535 002c 4FF00002 		mov	r2, #0
 1536 0030 9A64     		str	r2, [r3, #72]
 1537              	.L74:
 1538              		.loc 1 1526 0 discriminator 4
 1539 0032 FFF7FEFF 		bl	vPortExitCritical
1527:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 1540              		.loc 1 1527 0 is_stmt 1 discriminator 4
 1541 0036 7B68     		ldr	r3, [r7, #4]
 1542 0038 9B6B     		ldr	r3, [r3, #56]
 1543 003a 002B     		cmp	r3, #0
 1544 003c 06D1     		bne	.L75
1528:FreeRTOS/Source/queue.c **** 		{
1529:FreeRTOS/Source/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
1530:FreeRTOS/Source/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1545              		.loc 1 1530 0
 1546 003e 7B68     		ldr	r3, [r7, #4]
 1547 0040 03F12403 		add	r3, r3, #36
 1548 0044 1846     		mov	r0, r3
 1549 0046 3968     		ldr	r1, [r7, #0]
 1550 0048 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 1551              	.L75:
1531:FreeRTOS/Source/queue.c **** 		}
1532:FreeRTOS/Source/queue.c **** 		prvUnlockQueue( pxQueue );
 1552              		.loc 1 1532 0
 1553 004c 7868     		ldr	r0, [r7, #4]
 1554 004e FFF7FEFF 		bl	prvUnlockQueue
1533:FreeRTOS/Source/queue.c **** 	}
 1555              		.loc 1 1533 0
 1556 0052 07F10807 		add	r7, r7, #8
 1557 0056 BD46     		mov	sp, r7
 1558 0058 80BD     		pop	{r7, pc}
 1559              		.cfi_endproc
 1560              	.LFE126:
 1562 005a 00BF     		.text
 1563              	.Letext0:
 1564              		.file 2 "/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/include/stddef.h"
 1565              		.file 3 "/usr/local/csl/arm-2012.03/bin/../lib/gcc/arm-none-eabi/4.6.3/../../../../arm-none-eabi/i
 1566              		.file 4 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 1567              		.file 5 "FreeRTOS/Source/include/list.h"
 1568              		.file 6 "FreeRTOS/Source/include/task.h"
 1569              		.file 7 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/ccvqpYWo.s:20     .text.xQueueCreate:00000000 $t
     /tmp/ccvqpYWo.s:25     .text.xQueueCreate:00000000 xQueueCreate
     /tmp/ccvqpYWo.s:153    .text.xQueueCreateMutex:00000000 $t
     /tmp/ccvqpYWo.s:158    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/ccvqpYWo.s:253    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/ccvqpYWo.s:248    .text.xQueueGenericSend:00000000 $t
     /tmp/ccvqpYWo.s:1000   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/ccvqpYWo.s:1405   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/ccvqpYWo.s:1199   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/ccvqpYWo.s:427    .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/ccvqpYWo.s:432    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/ccvqpYWo.s:532    .text.xQueueGenericReceive:00000000 $t
     /tmp/ccvqpYWo.s:537    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/ccvqpYWo.s:1131   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/ccvqpYWo.s:1317   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/ccvqpYWo.s:769    .text.xQueueReceiveFromISR:00000000 $t
     /tmp/ccvqpYWo.s:774    .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/ccvqpYWo.s:876    .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/ccvqpYWo.s:881    .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/ccvqpYWo.s:918    .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/ccvqpYWo.s:923    .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/ccvqpYWo.s:957    .text.vQueueDelete:00000000 $t
     /tmp/ccvqpYWo.s:962    .text.vQueueDelete:00000000 vQueueDelete
     /tmp/ccvqpYWo.s:996    .text.prvCopyDataToQueue:00000000 $t
     /tmp/ccvqpYWo.s:1127   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/ccvqpYWo.s:1195   .text.prvUnlockQueue:00000000 $t
     /tmp/ccvqpYWo.s:1313   .text.prvIsQueueEmpty:00000000 $t
     /tmp/ccvqpYWo.s:1358   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/ccvqpYWo.s:1363   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/ccvqpYWo.s:1401   .text.prvIsQueueFull:00000000 $t
     /tmp/ccvqpYWo.s:1448   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/ccvqpYWo.s:1453   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/ccvqpYWo.s:1493   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/ccvqpYWo.s:1498   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
malloc
vListInitialise
free
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
